<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DiyTronic</title>
  <icon>https://www.gravatar.com/avatar/a9b217a127b6c6cfc50100bc6f5078ca</icon>
  <subtitle>Заметки об электронике, программировании, 3D-печати</subtitle>
  <link href="https://diytronic.ru/atom.xml" rel="self"/>
  
  <link href="https://diytronic.ru/"/>
  <updated>2023-01-08T14:24:48.407Z</updated>
  <id>https://diytronic.ru/</id>
  
  <author>
    <name>Роман Татауров</name>
    <email>diytronic@diytronic.ru</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Как запустить UART на Banana Pi BPI-M5</title>
    <link href="https://diytronic.ru/2023/01/07/howto-fix-uart-on-banana-pi-bpi-m5/"/>
    <id>https://diytronic.ru/2023/01/07/howto-fix-uart-on-banana-pi-bpi-m5/</id>
    <published>2023-01-07T17:28:24.000Z</published>
    <updated>2023-01-08T14:24:48.407Z</updated>
    
    <content type="html"><![CDATA[<p>По ходу работы над очередной поделкой, для которой я&nbsp;воспользовался завалявшейся у&nbsp;меня платой Banana Pi&nbsp;BPI-M5, мне потребовалось подключить к&nbsp;ней внешнее устройство по&nbsp;UART. </p><p>Вроде&nbsp;бы&nbsp;ничего хитрого, но&nbsp;неожиданно получил геморрой на&nbsp;ровном месте, в&nbsp;связи с&nbsp;чем пришлось углубиться в&nbsp;дебри маппинга пинов к&nbsp;устройствам чипа на&nbsp;плате. </p><p>Собственно этой информацией я&nbsp;и&nbsp;хочу поделиться, так как такое может возникнуть в&nbsp;любой момент, а&nbsp;нормальной информации по&nbsp;теме не&nbsp;так много. Статья получилась довольно занудной и&nbsp;сумбурной. Но&nbsp;уж&nbsp;как умею.</p><span id="more"></span><p>Итак Banana Pi&nbsp;BPI-M5. Я&nbsp;в&nbsp;курсе, что это довольно ублюдская поделка с&nbsp;кривой поддержкой и&nbsp;косяками, но&nbsp;что есть то&nbsp;есть. </p><p>На плату я&nbsp;решил накатить свой любимый Armbian, который тоже не&nbsp;отличается стабильностью, но&nbsp;для китайских плат нет ничего стабильного, а&nbsp;Raspberry PI&nbsp;я&nbsp;не&nbsp;хочу использовать в&nbsp;силу ряда причин.<br>Так что Armbian. Образ есть на&nbsp;сайте Armbian <a href="https://www.armbian.com/bananapi-m5/">https://www.armbian.com/bananapi-m5/</a>. Каких-то затруднений с&nbsp;установкой не&nbsp;было. </p><h1 id="Где-мой-UART"><a href="#Где-мой-UART" class="headerlink" title="Где мой UART?"></a>Где мой UART?</h1><p>На сайте с&nbsp;документацией есть <a href="https://wiki.banana-pi.org/Banana_Pi_BPI-M5#BPI-M5_40PIN_GPIO_.28CON2.29">распиновка</a>, согласно которой у&nbsp;нас есть два UART-а.<br>Один отладочный для вывода сообщений при загрузке, а&nbsp;второй выведен на&nbsp;гребёнку GPIO пинов (UART_A)  и&nbsp;типа может быть настроен по&nbsp;своему усмотрению&nbsp;&mdash; он&nbsp;то&nbsp;мне и&nbsp;нужен.</p><img src="/2023/01/07/howto-fix-uart-on-banana-pi-bpi-m5/uart-pins-on-board.png" class="" title="Board UART pins"><p>По умолчанию работает только отладочный UART и&nbsp;это нормально. Для подключения дополнительного оборудования у&nbsp;нас есть так называемые оверлеи, которые можно или прописать в&nbsp;файл <code>/boot/armbianEnv.txt </code> или воспользоваться программой <code>armbian-config</code>, в&nbsp;меню которой System -&gt; Hardware мы&nbsp;можем увидеть такую картину.</p><img src="/2023/01/07/howto-fix-uart-on-banana-pi-bpi-m5/armbian-overlays-setup.png" class="" title="Select Armbian overlays"><p>Вроде всё нормально, правда гложут сомнения какого чорта тут делает <code>uartC</code>. И&nbsp;как оказалось сомнения были не&nbsp;напрасны&nbsp;&mdash; действительно ни&nbsp;хрена не&nbsp;работает даже с&nbsp;включёнными оверлеями. </p><p>Поищем что-ли в&nbsp;логах загрузки.</p><pre class="code language language-bash"><code class="language language-bash"><span class="token comment"># dmesg | grep uart</span>ff803000.serial: ttyAML0 at MMIO 0xff803000 <span class="token punctuation">(</span>irq <span class="token operator">=</span> <span class="token number">14</span>, base_baud <span class="token operator">=</span> <span class="token number">1500000</span><span class="token punctuation">)</span> is a meson_uart</code></pre><p>Только одинокий <code>ttyAML0</code>. Это наш отладочный друг. Ни&nbsp;второго и&nbsp;ни&nbsp;уж&nbsp;тем более 3-го не&nbsp;видать. </p><h1 id="Погружаемся-в-оверлеи"><a href="#Погружаемся-в-оверлеи" class="headerlink" title="Погружаемся в оверлеи"></a>Погружаемся в&nbsp;оверлеи</h1><p>На самом деле это просто devicetree файлы с&nbsp;настройками устройств, применяемыми при загрузке. Эта штука работает в&nbsp;каждом компьютере (в частности я&nbsp;патчил свой ноутбук таким образом для более корректной работы в&nbsp;Linux)  и&nbsp;кстати любимый мной ZephyrRTOS так-же использует эту систему.</p><p>Но вернёмся к&nbsp;нашей ситуации. У&nbsp;нас эти оверлеи лежат&nbsp;тут:</p><pre class="code language language-bash"><code class="language language-bash"><span class="token comment"># ls -la /boot/dtb/amlogic/overlay/</span>total <span class="token number">44</span>drwxr-xr-x <span class="token number">2</span> root root <span class="token number">4096</span> Jan  <span class="token number">7</span> <span class="token number">21</span>:27 <span class="token builtin class-name">.</span>drwxr-xr-x <span class="token number">3</span> root root <span class="token number">4096</span> Oct <span class="token number">20</span> <span class="token number">12</span>:00 <span class="token punctuation">..</span>-rwxr-xr-x <span class="token number">1</span> root root  <span class="token number">232</span> Oct <span class="token number">20</span> <span class="token number">12</span>:00 meson-fixup.scr-rwxr-xr-x <span class="token number">1</span> root root  <span class="token number">377</span> Oct <span class="token number">20</span> <span class="token number">12</span>:00 meson-g12-gxl-cma-pool-896MB.dtbo-rwxr-xr-x <span class="token number">1</span> root root  <span class="token number">343</span> Oct <span class="token number">20</span> <span class="token number">12</span>:00 meson-i2cA.dtbo-rwxr-xr-x <span class="token number">1</span> root root  <span class="token number">343</span> Oct <span class="token number">20</span> <span class="token number">12</span>:00 meson-i2cB.dtbo-rwxr-xr-x <span class="token number">1</span> root root  <span class="token number">238</span> Oct <span class="token number">20</span> <span class="token number">12</span>:00 meson-uartA.dtbo  <span class="token comment"># &lt;==== вот наш пациент</span>-rwxr-xr-x <span class="token number">1</span> root root  <span class="token number">238</span> Oct <span class="token number">20</span> <span class="token number">12</span>:00 meson-uartC.dtbo-rwxr-xr-x <span class="token number">1</span> root root  <span class="token number">759</span> Oct <span class="token number">20</span> <span class="token number">12</span>:00 meson-w1AB-gpio.dtbo-rwxr-xr-x <span class="token number">1</span> root root  <span class="token number">490</span> Oct <span class="token number">20</span> <span class="token number">12</span>:00 meson-w1-gpio.dtbo-rwxr-xr-x <span class="token number">1</span> root root  <span class="token number">339</span> Oct <span class="token number">20</span> <span class="token number">12</span>:00 README.meson-overlays</code></pre><p>Но они в&nbsp;скомпилированом формате. Чтобы его декомпилировать воспользуемся командой <code>dtc</code></p><pre class="code language language-c"><code class="language language-c"><span class="token macro property"># dtc -I dtb -O dts /boot/dtb/amlogic/overlay/meson-uartA.dtbo</span><span class="token operator">/</span>dts<span class="token operator">-</span>v1<span class="token operator">/</span><span class="token punctuation">;</span><span class="token operator">/</span> <span class="token punctuation">{</span>        compatible <span class="token operator">=</span> <span class="token string">"amlogic,meson-gxbb"</span><span class="token punctuation">;</span>        fragment@<span class="token number">0</span> <span class="token punctuation">{</span>                target<span class="token operator">-</span>path <span class="token operator">=</span> <span class="token string">"/soc/bus@c1100000/serial@84c0"</span><span class="token punctuation">;</span>                __overlay__ <span class="token punctuation">{</span>                        status <span class="token operator">=</span> <span class="token string">"okay"</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>Ну и&nbsp;для интереса глянем, что это за&nbsp;девайс такой. Для этого залезем в&nbsp;живой devicetree устройства, расположенный в&nbsp;файловой системе в&nbsp;папке<code>/sys/firmware/devicetree/base/</code></p><pre class="code language language-bash"><code class="language language-bash"><span class="token comment"># ls -la /sys/firmware/devicetree/base/soc</span><span class="token punctuation">..</span>.drwxr-xr-x <span class="token number">16</span> root root  <span class="token number">0</span> Jan  <span class="token number">6</span> <span class="token number">22</span>:17  bus@ff600000drwxr-xr-x <span class="token number">14</span> root root  <span class="token number">0</span> Jan  <span class="token number">6</span> <span class="token number">22</span>:17  bus@ff800000drwxr-xr-x <span class="token number">19</span> root root  <span class="token number">0</span> Jan  <span class="token number">6</span> <span class="token number">22</span>:17  bus@ffd00000<span class="token punctuation">..</span>.</code></pre><p>Как видим никакого <code>bus@c1100000</code> у&nbsp;нас нет и&nbsp;в&nbsp;помине. В&nbsp;общем не&nbsp;буду томить&nbsp;&mdash; оверлеи в&nbsp;данной плате от&nbsp;<code>Odroid C4</code>. Видимо разрабы Armbian не&nbsp;стали заморачиваться и&nbsp;просто взяли оверлеи от&nbsp;похожего устройства на&nbsp;этом&nbsp;же&nbsp;чипе. Но&nbsp;не&nbsp;фортануло. </p><p>Ну что&nbsp;&mdash; изучим что&nbsp;же&nbsp;есть у&nbsp;нас.</p><pre class="code language language-bash"><code class="language language-bash"><span class="token comment"># ls -ls /sys/firmware/devicetree/base/soc/bus@ff800000/</span><span class="token punctuation">..</span>.<span class="token number">0</span> drwxr-xr-x <span class="token number">2</span> root root  <span class="token number">0</span> Jan  <span class="token number">6</span> <span class="token number">22</span>:17  serial@3000<span class="token number">0</span> drwxr-xr-x <span class="token number">2</span> root root  <span class="token number">0</span> Jan  <span class="token number">6</span> <span class="token number">22</span>:17  serial@4000<span class="token punctuation">..</span>.</code></pre><p>Уже что-то&nbsp;&mdash; есть два устройства с&nbsp;подозрительным именем <code>serial</code></p><pre class="code language language-bash"><code class="language language-bash"><span class="token comment"># ls -ls /sys/firmware/devicetree/base/soc/bus@ffd00000</span><span class="token punctuation">..</span>.<span class="token number">0</span> drwxr-xr-x <span class="token number">2</span> root root  <span class="token number">0</span> Jan  <span class="token number">6</span> <span class="token number">22</span>:17  serial@22000<span class="token number">0</span> drwxr-xr-x <span class="token number">2</span> root root  <span class="token number">0</span> Jan  <span class="token number">6</span> <span class="token number">22</span>:17  serial@23000<span class="token number">0</span> drwxr-xr-x <span class="token number">2</span> root root  <span class="token number">0</span> Jan  <span class="token number">6</span> <span class="token number">22</span>:17  serial@24000<span class="token punctuation">..</span>.</code></pre><p>Ну и&nbsp;три штуки по&nbsp;этому адресу. </p><p>В общем надо разобраться что тут&nbsp;что. </p><h2 id="Документация-к-чипу"><a href="#Документация-к-чипу" class="headerlink" title="Документация к чипу"></a>Документация к&nbsp;чипу</h2><p>В нашем случае это <a href="https://download.banana-pi.dev/d/3ebbfa04265d4dddb81b/files/?p=/Documents/BPI-M5/S905X3_Public_Datasheet_Hardkernel.pdf">Amlogic S905&times;3&nbsp;datasheet</a></p><p>Ищем раздел <code>13.5 Universal Asynchronious Receiver And Transmitter</code> и&nbsp;оттуда мы&nbsp;узнаём, что у&nbsp;нас и&nbsp;правда 5&nbsp;UART-ов. </p><p>Так-же оттуда мы&nbsp;узнаём, что 3&nbsp;обычных UART-а у&nbsp;нас расположены по&nbsp;базовому адресу <code>0xffd00000</code>.</p><p>Кроме того у&nbsp;нас есть 2&nbsp;always on&nbsp;UART-а. Скажем прямо&nbsp;&mdash; негусто.</p><h2 id="Исходники-Linux"><a href="#Исходники-Linux" class="headerlink" title="Исходники Linux"></a>Исходники Linux</h2><p>Далее я&nbsp;полез в&nbsp;исходники dts файлов для данной платы.</p><p>Вот родной dts файл для Banana Pi&nbsp;BPI-M5 <a href="https://github.com/torvalds/linux/blob/master/arch/arm64/boot/dts/amlogic/meson-sm1-bananapi-m5.dts">meson-sm1-bananapi-m5.dts</a></p><pre class="code language language-c"><code class="language language-c">aliases <span class="token punctuation">{</span>  serial0 <span class="token operator">=</span> <span class="token operator">&amp;</span>uart_AO<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>uart_AO <span class="token punctuation">{</span>status <span class="token operator">=</span> <span class="token string">"okay"</span><span class="token punctuation">;</span> <span class="token comment">/* uart_AO включается */</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>В котором у&nbsp;нас есть ссылка на&nbsp;некий <code>uart_AO</code>, который очень напоминает нам наш единственный доступный в&nbsp;системе дебаговый UART. То&nbsp;есть dts для Banana Pi&nbsp;BPI-M5&nbsp;просто включает <code>uart_AO</code>. Осталось найти где этот <code>uart_AO</code> описан, т.&nbsp;к.&nbsp;здесь просто ссылка на&nbsp;него.</p><p>Ну и&nbsp;у&nbsp;нас нет остальных UART-ов, поэтому открываем по&nbsp;очереди файлы из&nbsp;include и&nbsp;в&nbsp;конце концов натыкаемся на&nbsp;россыпь UART-ов в&nbsp;файле <a href="https://github.com/torvalds/linux/blob/master/arch/arm64/boot/dts/amlogic/meson-g12-common.dtsi">meson-g12-common.dtsi</a>. </p><pre class="code language language-c"><code class="language language-c">aobus<span class="token operator">:</span> bus@ff800000 <span class="token punctuation">{</span>              uart_AO<span class="token operator">:</span> serial@<span class="token number">3000</span> <span class="token punctuation">{</span> <span class="token comment">/* &lt;=== этот адрес мы видели в логе загрузки */</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      status <span class="token operator">=</span> <span class="token string">"disabled"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    uart_AO_B<span class="token operator">:</span> serial@<span class="token number">4000</span> <span class="token punctuation">{</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      status <span class="token operator">=</span> <span class="token string">"disabled"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>cbus<span class="token operator">:</span> bus@ffd00000 <span class="token punctuation">{</span>    uart_C<span class="token operator">:</span> serial@<span class="token number">22000</span> <span class="token punctuation">{</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      status <span class="token operator">=</span> <span class="token string">"disabled"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    uart_B<span class="token operator">:</span> serial@<span class="token number">23000</span> <span class="token punctuation">{</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      status <span class="token operator">=</span> <span class="token string">"disabled"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    uart_A<span class="token operator">:</span> serial@<span class="token number">24000</span> <span class="token punctuation">{</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      fifo<span class="token operator">-</span>size <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token number">128</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">/* в доке к чипу упоминалось что UART_A имеет буффер в 128k */</span>      status <span class="token operator">=</span> <span class="token string">"disabled"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Видим, что количество UART-ов и&nbsp;адреса шин подозрительно совпадают с&nbsp;тем, что мы&nbsp;обнаружили изучая devicetree работающего устройства. </p><p>Так&nbsp;же&nbsp;видим, что все устройства в&nbsp;состоянии disabled. Включен (см. выше про <a href="https://github.com/torvalds/linux/blob/master/arch/arm64/boot/dts/amlogic/meson-sm1-bananapi-m5.dts">meson-sm1-bananapi-m5.dts</a>)  только <code>uart_AO</code> который имеет адрес <code>aobus: bus@ff800000 serial@3000</code>, то&nbsp;есть то&nbsp;самое <code>MMIO 0xff803000</code> из&nbsp;лога загрузки. Короче это точно наш дебаговый UART.</p><p>Надо попробовать включить <code>uart_A</code>. Для этого сохраняем декомпилированный оверлей в&nbsp;файл с&nbsp;расширением dts и&nbsp;меняем там адрес UART-а на&nbsp;обнаруженный нами, то&nbsp;есть получим что-то вот такое</p><pre class="code language language-bash"><code class="language language-bash"><span class="token comment"># dtc -I dtb -O dts -f /boot/dtb/amlogic/overlay/meson-uartA.dtbo -o /root/meson-uartA.dts</span></code></pre><p>Далее редактируем meson-uartA.dts</p><pre class="code language language-c"><code class="language language-c"><span class="token operator">/</span>dts<span class="token operator">-</span>v1<span class="token operator">/</span><span class="token punctuation">;</span><span class="token operator">/</span>plugin<span class="token operator">/</span><span class="token punctuation">;</span>  <span class="token comment">/* &lt;=== это надо добавить т.к. у нас оверлей */</span><span class="token operator">/</span> <span class="token punctuation">{</span>        compatible <span class="token operator">=</span> <span class="token string">"amlogic,meson-gxbb"</span><span class="token punctuation">;</span>        fragment@<span class="token number">0</span> <span class="token punctuation">{</span>                target<span class="token operator">-</span>path <span class="token operator">=</span> <span class="token string">"/soc/bus@ffd00000/serial@24000"</span><span class="token punctuation">;</span>  <span class="token comment">/* &lt;=== меняем адрес */</span>                __overlay__ <span class="token punctuation">{</span>                        status <span class="token operator">=</span> <span class="token string">"okay"</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>И устанавливаем, предварительно удалив старые uart оверлеи.</p><pre class="code language language-bash"><code class="language language-bash"><span class="token comment"># armbian-add-overlay meson-uartA.dts</span>Compiling the overlayCopying the compiled overlay <span class="token function">file</span> to /boot/overlay-user/Reboot is required to apply the changes</code></pre><p>Как вариант с&nbsp;помощью dtc можно скомпилировать и&nbsp;подменить файлы вручную, но&nbsp;так проще. </p><p>После перезагрузки видим 2&nbsp;устройства. Работает!</p><pre class="code language language-bash"><code class="language language-bash">% <span class="token function">sudo</span> <span class="token function">dmesg</span> <span class="token operator">|</span> <span class="token function">grep</span> _uartff803000.serial: ttyAML0 at MMIO 0xff803000 <span class="token punctuation">(</span>irq <span class="token operator">=</span> <span class="token number">14</span>, base_baud <span class="token operator">=</span> <span class="token number">1500000</span><span class="token punctuation">)</span> is a meson_uartffd24000.serial: ttyAML1 at MMIO 0xffd24000 <span class="token punctuation">(</span>irq <span class="token operator">=</span> <span class="token number">15</span>, base_baud <span class="token operator">=</span> <span class="token number">1500000</span><span class="token punctuation">)</span> is a meson_uart</code></pre><p>Но радость была недолгой. При подключении к&nbsp;порту реального устройства оказалось, что обмен идёт только в&nbsp;одну сторону. Короче RX&nbsp;работает, а&nbsp;TX&nbsp;&mdash;&nbsp;нет.</p><h1 id="Разборки-с-пинами"><a href="#Разборки-с-пинами" class="headerlink" title="Разборки с пинами"></a>Разборки с&nbsp;пинами</h1><p>Очевидно, что какая-то проблема с&nbsp;настройкой пинов. Подключаемая железка гарантировано работала. На&nbsp;пины я&nbsp;убил 3&nbsp;вечера. </p><p>Проверим, что у&nbsp;нас с&nbsp;пинами. По&nbsp;счастью эта информация есть в&nbsp;нашем текущем devicetree</p><p>Итак начнём. Поищем какие пины и&nbsp;как назначены нашим устройствам. Конкретно нас интересует UART_A, который как мы&nbsp;выяснили имеет адрес ffd24000.</p><pre class="code language language-bash"><code class="language language-bash"><span class="token comment"># cat /sys/kernel/debug/pinctrl/pinctrl-maps | grep ffd24000 -A 8</span>device ffd24000.serialstate default<span class="token builtin class-name">type</span> MUX_GROUP <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>controlling device ff634400.bus:pinctrl@40  <span class="token comment"># &lt;== вот это нам и надо</span>group uart_a_tx                             <span class="token comment"># &lt;== и вот это</span><span class="token keyword">function</span> uart_adevice ffd24000.serialstate default<span class="token builtin class-name">type</span> CONFIGS_GROUP <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>controlling device ff634400.bus:pinctrl@40group uart_a_txconfig 00000001device ffd24000.serialstate default<span class="token builtin class-name">type</span> MUX_GROUP <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>controlling device ff634400.bus:pinctrl@40group uart_a_rx<span class="token keyword">function</span> uart_adevice ffd24000.serialstate default<span class="token builtin class-name">type</span> CONFIGS_GROUP <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>controlling device ff634400.bus:pinctrl@40group uart_a_rxconfig 00000001device ffd24000.serialstate default<span class="token builtin class-name">type</span> MUX_GROUP <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>controlling device ff634400.bus:pinctrl@40group uart_a_tx<span class="token keyword">function</span> uart_adevice ffd24000.serialstate default<span class="token builtin class-name">type</span> CONFIGS_GROUP <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>controlling device ff634400.bus:pinctrl@40group uart_a_txconfig 000fa00aconfig 0000000cconfig 00000112</code></pre><p>Теперь мы&nbsp;знаем адрес устройства на&nbsp;шине, которое заведует нужными нам пинами и&nbsp;конкретные группы пинов. Теперь лезем обратно в&nbsp;dts <a href="https://github.com/torvalds/linux/blob/master/arch/arm64/boot/dts/amlogic/meson-g12-common.dtsi">meson-g12-common.dtsi</a> и&nbsp;ищем это устройство.</p><pre class="code language language-bash"><code class="language language-bash">soc <span class="token punctuation">{</span>apb: bus@ff600000 <span class="token punctuation">{</span>    /* <span class="token operator">&lt;</span><span class="token operator">==</span><span class="token operator">=</span> вот адрес шины */    <span class="token punctuation">..</span>.periphs: bus@34400 <span class="token punctuation">{</span> /* <span class="token operator">&lt;</span><span class="token operator">==</span><span class="token operator">=</span> вот адрес внутри шины */      <span class="token punctuation">..</span>.periphs_pinctrl: pinctrl@40 <span class="token punctuation">{</span> /* <span class="token operator">&lt;</span><span class="token operator">==</span><span class="token operator">=</span> устройство */        <span class="token punctuation">..</span>.uart_a_pins: uart-a <span class="token punctuation">{</span>mux <span class="token punctuation">{</span><span class="token function">groups</span> <span class="token operator">=</span> <span class="token string">"uart_a_tx"</span>, <span class="token string">"uart_a_rx"</span><span class="token punctuation">;</span> /* <span class="token operator">&lt;</span><span class="token operator">==</span><span class="token operator">==</span> пины */<span class="token keyword">function</span> <span class="token operator">=</span> <span class="token string">"uart_a"</span><span class="token punctuation">;</span>bias-disable<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>И что&nbsp;же&nbsp;мы&nbsp;тут видим? А&nbsp;видим&nbsp;мы, что и&nbsp;TX&nbsp;и&nbsp;RX&nbsp;объединены в&nbsp;одну группу и&nbsp;имеют общие настройки, что довольно странно.</p><p>Поищем ещё поглубже</p><pre class="code language language-bash"><code class="language language-bash"><span class="token comment"># ls -la /sys/kernel/debug/pinctrl</span>total <span class="token number">0</span>drwxr-xr-x  <span class="token number">2</span> ff634400.bus:pinctrl@40-pinctrl-meson  <span class="token comment"># &lt;== вот эта папка что-то напоминает</span>drwxr-xr-x  <span class="token number">2</span> ff800000.sys-ctrl:pinctrl@14-pinctrl-meson-r--r--r--  <span class="token number">1</span> pinctrl-devices-r--r--r--  <span class="token number">1</span> pinctrl-handles-r--r--r--  <span class="token number">1</span> pinctrl-maps  <span class="token comment"># &lt;== это мы только что смотрели</span></code></pre><p>Нас интересует файл pinconf-pins</p><pre class="code language language-bash"><code class="language language-bash"><span class="token comment"># cat /sys/kernel/debug/pinctrl/ff634400.bus:pinctrl@40-pinctrl-meson/pinconf-pins | grep GPIOX_1</span><span class="token punctuation">..</span>.pin <span class="token number">77</span> <span class="token punctuation">(</span>GPIOX_12<span class="token punctuation">)</span>: input bias disabled, output drive strength <span class="token punctuation">(</span><span class="token number">2500</span> uA<span class="token punctuation">)</span>pin <span class="token number">78</span> <span class="token punctuation">(</span>GPIOX_13<span class="token punctuation">)</span>: input bias disabled, output drive strength <span class="token punctuation">(</span><span class="token number">2500</span> uA<span class="token punctuation">)</span><span class="token punctuation">..</span>.</code></pre><p>GPIOX_12 и&nbsp;GPIOX_13&nbsp;упоминаются в&nbsp;распиновке по&nbsp;ссылке выше как соответственно UART_A_TX и&nbsp;UART_A_RX.</p><p>Вроде и&nbsp;всё&nbsp;бы&nbsp;ничего, но&nbsp;некоторые другие пины имеют среди прочего <code>output enabled</code>. Видимо стоит это как-то указать. Ну&nbsp;и&nbsp;забегая вперёд кроме добавления TX&nbsp;пину возможности работать на&nbsp;вывод, нужно ещё убрать ему возможность работать на&nbsp;вход. Оба условия оказались необходимы, иначе ничего не&nbsp;работало.</p><p>Полный набор возможных опций для пинов можно посмотреть тут <a href="https://github.com/torvalds/linux/blob/master/drivers/pinctrl/pinconf-generic.c#L160">pinconf-generic.c</a></p><p>В итоге наш финальный оверлей принял следующий&nbsp;вид. </p><pre class="code language language-c"><code class="language language-c"><span class="token operator">/</span>dts<span class="token operator">-</span>v1<span class="token operator">/</span><span class="token punctuation">;</span><span class="token operator">/</span>plugin<span class="token operator">/</span><span class="token punctuation">;</span><span class="token operator">/</span> <span class="token punctuation">{</span>    compatible <span class="token operator">=</span> <span class="token string">"amlogic,meson-gxbb"</span><span class="token punctuation">;</span>    fragment@<span class="token number">0</span> <span class="token punctuation">{</span>        target<span class="token operator">-</span>path <span class="token operator">=</span> <span class="token string">"/soc/bus@ff600000/bus@34400/pinctrl@40"</span><span class="token punctuation">;</span> <span class="token comment">/* для данного устройства */</span>        __overlay__ <span class="token punctuation">{</span>            uart_a_tx_pin<span class="token operator">:</span> uart<span class="token operator">-</span>a<span class="token operator">-</span>tx <span class="token punctuation">{</span> <span class="token comment">/* добавляем настройки пинов */</span>                mux <span class="token punctuation">{</span>                    groups <span class="token operator">=</span> <span class="token string">"uart_a_tx"</span><span class="token punctuation">;</span> <span class="token comment">/* для группы пинов "uart_a_tx"                    function = "uart_a";  /* это как было в оригинальной группе */</span>                    input<span class="token operator">-</span>disable<span class="token punctuation">;</span>        <span class="token comment">/* для TX выключаем input - обязательно! */</span>                    output<span class="token operator">-</span>enable<span class="token punctuation">;</span>        <span class="token comment">/* для TX включаем output - обязательно! */</span>                    drive<span class="token operator">-</span>strength<span class="token operator">-</span>microamp <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token number">4000</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">/* это наверно необязательно */</span>                <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    fragment@<span class="token number">1</span> <span class="token punctuation">{</span>        target<span class="token operator">-</span>path <span class="token operator">=</span> <span class="token string">"/soc/bus@ffd00000/serial@24000"</span><span class="token punctuation">;</span>  <span class="token comment">/* &lt;=== меняем адрес (см. выше) */</span>        __overlay__ <span class="token punctuation">{</span>            status <span class="token operator">=</span> <span class="token string">"okay"</span><span class="token punctuation">;</span>                             <span class="token comment">/* включаем UART */</span>            pinctrl<span class="token operator">-</span><span class="token number">0</span> <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token operator">&amp;</span>uart_a_pins <span class="token operator">&amp;</span>uart_a_tx_pin<span class="token operator">></span><span class="token punctuation">;</span>   <span class="token comment">/* добавляем uart_a_tx_pin из блока выше */</span>            pinctrl<span class="token operator">-</span>names <span class="token operator">=</span> <span class="token string">"default"</span><span class="token punctuation">;</span>                   <span class="token comment">/* это возможно необязательно */</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>Устанавливаем этот оверлей и&nbsp;после перезагрузки получаем полноценно работающий UART_A согласно официальной распиновке.</p><p>Настройки пинов при этом приняли следующий&nbsp;вид. Видим, что у&nbsp;TX&nbsp;(GPIOX_12)  появился <code>output-enabled</code></p><pre class="code language language-bash"><code class="language language-bash"><span class="token comment"># cat /sys/kernel/debug/pinctrl/ff634400.bus:pinctrl@40-pinctrl-meson/pinconf-pins | grep GPIOX_1</span><span class="token punctuation">..</span>.pin <span class="token number">77</span> <span class="token punctuation">(</span>GPIOX_12<span class="token punctuation">)</span>: input bias disabled, output drive strength <span class="token punctuation">(</span><span class="token number">4000</span> uA<span class="token punctuation">)</span>, output enabled, pin output <span class="token punctuation">(</span><span class="token number">1</span> level<span class="token punctuation">)</span>pin <span class="token number">78</span> <span class="token punctuation">(</span>GPIOX_13<span class="token punctuation">)</span>: input bias disabled, output drive strength <span class="token punctuation">(</span><span class="token number">2500</span> uA<span class="token punctuation">)</span><span class="token punctuation">..</span>.</code></pre><h1 id="Итого"><a href="#Итого" class="headerlink" title="Итого"></a>Итого</h1><p>После всех злоключений удалось таки запустить этот чортов UART и&nbsp;успешно подключить к&nbsp;нему железяку. Я&nbsp;счастлив, особенно учитывая количество убитого времени. Надеюсь кому-нибудь будет полезно.</p>]]></content>
    
    
    <summary type="html">Как запустить UART на Banana Pi BPI-M5</summary>
    
    
    
    <category term="uncategorized" scheme="https://diytronic.ru/categories/uncategorized/"/>
    
    
    <category term="Armbian" scheme="https://diytronic.ru/tags/Armbian/"/>
    
    <category term="Banana PI" scheme="https://diytronic.ru/tags/Banana-PI/"/>
    
    <category term="Amlogic S905X3" scheme="https://diytronic.ru/tags/Amlogic-S905X3/"/>
    
    <category term="S905X3" scheme="https://diytronic.ru/tags/S905X3/"/>
    
    <category term="UART" scheme="https://diytronic.ru/tags/UART/"/>
    
    <category term="Devicetree" scheme="https://diytronic.ru/tags/Devicetree/"/>
    
    <category term="DTS" scheme="https://diytronic.ru/tags/DTS/"/>
    
  </entry>
  
  <entry>
    <title>Запускаем Wi-Fi на Orange Pi Zero Plus 2 H3</title>
    <link href="https://diytronic.ru/2022/11/11/fixing-wi-fi-issues-on-orange-pi-zero-plus-2-h3/"/>
    <id>https://diytronic.ru/2022/11/11/fixing-wi-fi-issues-on-orange-pi-zero-plus-2-h3/</id>
    <published>2022-11-11T02:25:17.000Z</published>
    <updated>2022-11-13T17:22:14.801Z</updated>
    
    <content type="html"><![CDATA[<p>В ходе настройки Orange Pi&nbsp;Zero Plus 2 H3&nbsp;обнаружил, что есть конкретные проблемы с&nbsp;Wi-Fi. В&nbsp;зависимости от&nbsp;используемого дистрибутива Linux имеем либо негрузящайся драйвер, либо работают только первые 11&nbsp;каналов Wi-Fi, а&nbsp;учитывая, что моих сетей там&nbsp;нет, это проблема, которую пришлось решать. Решение я&nbsp;нашёл и&nbsp;ниже я&nbsp;его вам покажу и&nbsp;расскажу как с&nbsp;этой проблемой бороться. </p><span id="more"></span><p>Итак, хотелось мне запустить эту плату именно в&nbsp;Armbin, но&nbsp;именно этот дистрибутив славился&nbsp;тем, что данная плата в&nbsp;нём Wi-Fi не&nbsp;поддерживала. Но&nbsp;мы&nbsp;не&nbsp;ищем лёгких путей и&nbsp;из-за какого-то там чортова драйвера менять дистрибутив для меня просто унижение. Если драйвер есть и&nbsp;он&nbsp;в&nbsp;принципе работает, то&nbsp;и&nbsp;в&nbsp;Armbian он&nbsp;у&nbsp;меня заработает. Вызов принят!</p><h2 id="Получаем-проблему"><a href="#Получаем-проблему" class="headerlink" title="Получаем проблему"></a>Получаем проблему</h2><p>Итак, первым делом накатываем Armbian. На&nbsp;официальной стрaнице образа для данной платы я&nbsp;не&nbsp;нашёл, но&nbsp;зато нашёл где эти сборки выкладываются. В&nbsp;общем качаем отсюда <a href="https://fi.mirror.armbian.de/archive/orangepizeroplus2-h3/archive/">https://fi.mirror.armbian.de/archive/orangepizeroplus2-h3/archive/</a>. Я&nbsp;использовал версию bullseye. Пробовал jammy, но&nbsp;там ровно тоже самое.</p><h2 id="Альтернативные-драйвера"><a href="#Альтернативные-драйвера" class="headerlink" title="Альтернативные драйвера"></a>Альтернативные драйвера</h2><p>Они существуют и&nbsp;возможно работают. </p><ul><li><a href="https://github.com/antoineco/broadcom-wl">https://github.com/antoineco/broadcom-wl</a></li><li><a href="http://linuxwireless.sipsolutions.net/en/users/Drivers/b43/">http://linuxwireless.sipsolutions.net/en/users/Drivers/b43/</a></li></ul><p>Проблема одна&nbsp;&mdash; их&nbsp;надо качать, а&nbsp;сети&nbsp;нет. Можно конечно скачать код на&nbsp;другом компьютере, залить на&nbsp;карточку и&nbsp;попытаться собрать на&nbsp;плате, но&nbsp;слишком много возни и&nbsp;вероятно потребуется докачивать зависимости.</p><h2 id="Анализируем-ошибки"><a href="#Анализируем-ошибки" class="headerlink" title="Анализируем ошибки"></a>Анализируем ошибки</h2><p>В итоге имеем условно работающий Wi-Fi из&nbsp;каробки с&nbsp;куцым списком доступных сетей и&nbsp;ошибки в&nbsp;логах при загрузке фирмвари данного драйвера.</p><p>Ошибки выглядят так </p><pre class="code language language-bash"><code class="language language-bash">% <span class="token function">dmesg</span> <span class="token operator">|</span> <span class="token function">grep</span> brcmbrcmfmac: brcmf_fw_alloc_request: using brcm/brcmfmac43430-sdio <span class="token keyword">for</span> chip BCM43430/1brcmfmac mmc1:0001:1: Direct firmware load <span class="token keyword">for</span> brcm/brcmfmac43430-sdio.xunlong,orangepi-zero-plus2-h3.bin failed with error -2brcmfmac mmc1:0001:1: Falling back to sysfs fallback for: brcm/brcmfmac43430-sdio.xunlong,orangepi-zero-plus2-h3.binbrcmfmac mmc1:0001:1: Direct firmware load <span class="token keyword">for</span> brcm/brcmfmac43430-sdio.xunlong,orangepi-zero-plus2-h3.txt failed with error -2brcmfmac mmc1:0001:1: Falling back to sysfs fallback for: brcm/brcmfmac43430-sdio.xunlong,orangepi-zero-plus2-h3.txtbrcmfmac: brcmf_fw_alloc_request: using brcm/brcmfmac43430-sdio <span class="token keyword">for</span> chip BCM43430/1brcmfmac: brcmf_c_process_clm_blob: no clm_blob available <span class="token punctuation">(</span>err<span class="token operator">=</span>-2<span class="token punctuation">)</span>, device may have limited channels availablebrcmfmac: brcmf_c_preinit_dcmds: Firmware: BCM43430/1 wl0: Mar <span class="token number">30</span> <span class="token number">2016</span> <span class="token number">11</span>:30:56 version <span class="token number">7.45</span>.77.h8.4 FWID 01-ee8a6268</code></pre><p>Как видно оно пытается загрузить какую-то фирмварь и&nbsp;не&nbsp;может найти нужных файлов. Придётся таки разбираться, что такое firmware и&nbsp;как оно грузится</p><h2 id="Linux-и-firmware"><a href="#Linux-и-firmware" class="headerlink" title="Linux и firmware"></a>Linux и&nbsp;firmware</h2><p>В общем, как выяснилось, для всяких проприетарных драйверов типа Broadcom-а у&nbsp;нас есть бинарные файлы (та самая firmware), которые и&nbsp;подгружаются родным линуксовым драйвером, чтобы всё работало как надо. Но&nbsp;кроме бинарника у&nbsp;нас есть некий конфиг, который есть ни&nbsp;что иное как набор переменных, которые заливаются в&nbsp;NVRAM драйвера. </p><h2 id="Что-не-так-в-нашем-случае"><a href="#Что-не-так-в-нашем-случае" class="headerlink" title="Что не так в нашем случае"></a>Что не&nbsp;так в&nbsp;нашем случае</h2><p>Для нашего случая всё выглядит вот&nbsp;так.</p><pre class="code language language-bash"><code class="language language-bash">% <span class="token function">ls</span> -la /lib/firmware/brcm/*43430*<span class="token punctuation">..</span>./lib/firmware/brcm/brcmfmac43430-sdio.bin   <span class="token comment"># &lt;=== бинарник фирмвари</span>/lib/firmware/brcm/brcmfmac43430-sdio.txt   <span class="token comment"># &lt;=== конфиг</span></code></pre><p>Но как видно из&nbsp;ошибки, драйвер пытается загрузить firmware из&nbsp;файла с&nbsp;суффиксом вендора устройства, то&nbsp;есть <code>/lib/firmware/brcm/brcmfmac43430-sdio.xunlong,orangepi-zero-plus2-h3.bin</code> вместо <code>/lib/firmware/brcm/brcmfmac43430-sdio.bin</code>. Поэтому я&nbsp;решил просто создать нужные симлинки. </p><p>Забегая вперёд должен отметить, что это оказалось необязательно, а&nbsp;эта ошибка это скорее предупреждение. Походу драйвер таки находит фирмварь и&nbsp;по&nbsp;существующим именам. Но&nbsp;что сделано, то&nbsp;сделано и&nbsp;как минимум убираются сообщения об&nbsp;ошибках при загрузке.</p><p>После исправления имеем такую картину.</p><pre class="code language language-bash"><code class="language language-bash">% <span class="token function">ls</span> -la /lib/firmware/brcm/*43430*<span class="token punctuation">..</span>./lib/firmware/brcm/brcmfmac43430-sdio.bin   <span class="token comment"># &lt;=== бинарник фирмвари</span>/lib/firmware/brcm/brcmfmac43430-sdio.txt   <span class="token comment"># &lt;=== конфиг</span>/lib/firmware/brcm/brcmfmac43430-sdio.xunlong,orangepi-zero-plus2-h3.bin -<span class="token operator">></span> /lib/firmware/brcm/brcmfmac43430-sdio.bin/lib/firmware/brcm/brcmfmac43430-sdio.xunlong,orangepi-zero-plus2-h3.txt -<span class="token operator">></span> /lib/firmware/brcm/brcmfmac43430-sdio.txt</code></pre><p>Теперь при загрузке видим следующее</p><pre class="code language language-bash"><code class="language language-bash">% <span class="token function">dmesg</span> <span class="token operator">|</span> <span class="token function">grep</span> brcmbrcmfmac: brcmf_fw_alloc_request: using brcm/brcmfmac43430-sdio <span class="token keyword">for</span> chip BCM43430/1 <span class="token comment"># &lt;== стало норм</span>brcmfmac: brcmf_fw_alloc_request: using brcm/brcmfmac43430-sdio <span class="token keyword">for</span> chip BCM43430/1 <span class="token comment"># &lt;== стало норм</span>brcmfmac: brcmf_c_process_clm_blob: no clm_blob available <span class="token punctuation">(</span>err<span class="token operator">=</span>-2<span class="token punctuation">)</span>, device may have limited channels availablebrcmfmac: brcmf_c_preinit_dcmds: Firmware: BCM43430/1 wl0: Mar <span class="token number">30</span> <span class="token number">2016</span> <span class="token number">11</span>:30:56 version <span class="token number">7.45</span>.77.h8.4 FWID 01-ee8a6268</code></pre><h2 id="Задаём-код-региона"><a href="#Задаём-код-региона" class="headerlink" title="Задаём код региона"></a>Задаём код региона</h2><p>Несмотря на&nbsp;успешную загрузку фирмвари, нас осталась ошибка как раз насчёт ограничения каналов и&nbsp;фирмварь ругается на&nbsp;какой-то <code>clm_blob</code>. Это как оказалось ещё один бинарник с&nbsp;региональными настройками для данного драйвера. И&nbsp;с&nbsp;этими самыми настройками полная чехарда. В&nbsp;разное время за&nbsp;это дело отвечали следующие подсистемы.</p><h3 id="CRDA-central-regulatory-domain-agent"><a href="#CRDA-central-regulatory-domain-agent" class="headerlink" title="CRDA (central regulatory domain agent)"></a>CRDA (central regulatory domain agent) </h3><p>С этим связаны рекоммендации поправить регион в&nbsp;<code>/etc/default/crda</code>, но&nbsp;нифига не&nbsp;работает, так как эта тема устарела с&nbsp;версии ядра 4.15</p><h3 id="cfg80211"><a href="#cfg80211" class="headerlink" title="cfg80211"></a>cfg80211</h3><p>Есть так&nbsp;же&nbsp;рекоммендации передать регион драйверу Linux cfg80211, но&nbsp;это тоже устарело и&nbsp;сегодня каждый драйвер должен сам уметь разбираться с&nbsp;такими делами. </p><pre class="code language language-bash"><code class="language language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"options cfg80211 ieee80211_regdom=US"</span> <span class="token operator">></span> /etc/modprobe.d/cfg80211.conf</code></pre><h3 id="clm-blob"><a href="#clm-blob" class="headerlink" title="clm_blob"></a>clm_blob</h3><p>Это по&nbsp;факту кусок базы данных, типа&nbsp;той, что использовалась в&nbsp;CRDA, но&nbsp;специфичный для данного драйвера. Как оказалось и&nbsp;этот метод устарел и&nbsp;вся информация уже должна содержаться в&nbsp;недрах драйвера. К&nbsp;слову я&nbsp;таки нашёл этот бинарь от&nbsp;Raspberry PI&nbsp;и&nbsp;подсунул для загрузки, но&nbsp;работать лучше не&nbsp;стало.</p><h3 id="И-что-таки-делать"><a href="#И-что-таки-делать" class="headerlink" title="И что таки делать?"></a>И что таки делать?</h3><p>В итоге пришлось лезть в&nbsp;конфиг фирмвари и&nbsp;уже там я&nbsp;обнаружил подозрительную переменную <code>ccode=ALL</code>, поменяв значение которой, после перезагрузки я&nbsp;получил полный список Wi-Fi сетей.</p><pre class="code language language-ini"><code class="language language-ini"><span class="token comment">#AP6212_NVRAM_V1.0_20140603</span><span class="token comment"># 2.4 GHz, 20 MHz BW mode</span><span class="token comment"># The following parameter values are just placeholders, need to be updated.</span>.....<span class="token constant">xtalfreq</span><span class="token attr-value"><span class="token punctuation">=</span>26000</span><span class="token constant">nocrc</span><span class="token attr-value"><span class="token punctuation">=</span>1</span><span class="token constant">ag0</span><span class="token attr-value"><span class="token punctuation">=</span>255</span><span class="token constant">aa2g</span><span class="token attr-value"><span class="token punctuation">=</span>1</span><span class="token constant">ccode</span><span class="token attr-value"><span class="token punctuation">=</span>ALL # &lt;===== вот тут меняем ALL на RU </span><span class="token constant">extpagain2g</span><span class="token attr-value"><span class="token punctuation">=</span>0</span>........</code></pre><p>Но тут есть проблема&nbsp;&mdash; при обновлении пакета с&nbsp;фирмварями этот файл будет перезаписываться. </p><h1 id="Всё-чудесатее-и-чудесатее"><a href="#Всё-чудесатее-и-чудесатее" class="headerlink" title="Всё чудесатее и чудесатее"></a>Всё чудесатее и&nbsp;чудесатее</h1><p>Гугля по&nbsp;теме обнаружил ссылки на&nbsp;исходники с&nbsp;такими комментариями</p><pre class="code"><code>/* In some cases the EFI-var stored nvram contains "ccode=ALL" or * "ccode=XV" to specify "worldwide" compatible settings. ccode=ALL is * not understood by the firmware and some of the firmware files in * linux-firmware support only 2.4 GHz and not 5 GHz when ccode=XV. */</code></pre><p>Так, что видимо стоит попробовать вместо <strong>RU</strong> использовать <strong>XV</strong>. Возможно даже появится диапазон 5ГГц.</p><h1 id="Я-сдаюсь"><a href="#Я-сдаюсь" class="headerlink" title="Я сдаюсь"></a>Я сдаюсь</h1><p>Кроме всего прочего искал способ прописать ccode в&nbsp;драйвер через /proc или /sys.<br>Декомпилировал devicetree в&nbsp;надежде найти там способ перезаписать значения NVRAM.</p><p>Все тщетно. Походу эти фирмвари и&nbsp;драйвера для Broadcom писались через жопу, на&nbsp;скорую руку и&nbsp;всё, что нам остаётся это грязно патчить через подмену значения в&nbsp;этом текстовом конфиге.</p><h1 id="Итого"><a href="#Итого" class="headerlink" title="Итого"></a>Итого</h1><p>Как оказалось в&nbsp;принципе по&nbsp;минимуму достаточно поменять <code>ccode=ALL</code> на&nbsp;<code>ccode=RU</code> в&nbsp;конфиге фирмвари драйвера. </p><p>И видимо в&nbsp;автозагрузку придётся добавить скрипт для замены ccode в&nbsp;нужном файле.</p><h1 id="Ссылки"><a href="#Ссылки" class="headerlink" title="Ссылки"></a>Ссылки</h1><ul><li><a href="https://help.ubuntu.com/community/WifiDocs/Driver/bcm43xx">https://help.ubuntu.com/community/WifiDocs/Driver/bcm43xx</a></li><li><a href="https://wireless.wiki.kernel.org/en/users/Drivers/brcm80211">https://wireless.wiki.kernel.org/en/users/Drivers/brcm80211</a></li></ul>]]></content>
    
    
    <summary type="html">Как исправить проблемы с Wi-Fi на платах типа Orange Pi Zero Plus 2 H3/H5 при использовании ОС Armbian</summary>
    
    
    
    <category term="uncategorized" scheme="https://diytronic.ru/categories/uncategorized/"/>
    
    
    <category term="Armbian" scheme="https://diytronic.ru/tags/Armbian/"/>
    
    <category term="Orange Pi" scheme="https://diytronic.ru/tags/Orange-Pi/"/>
    
    <category term="Orange Pi Zero Plus 2 H3" scheme="https://diytronic.ru/tags/Orange-Pi-Zero-Plus-2-H3/"/>
    
    <category term="Broadcom" scheme="https://diytronic.ru/tags/Broadcom/"/>
    
    <category term="Broadcom BCM43430" scheme="https://diytronic.ru/tags/Broadcom-BCM43430/"/>
    
  </entry>
  
  <entry>
    <title>Пишем драйвер ИК термодатчика MLX90614 для Zephyr RTOS</title>
    <link href="https://diytronic.ru/2018/04/24/writing-mlx90614-zephyr-rtos-driver/"/>
    <id>https://diytronic.ru/2018/04/24/writing-mlx90614-zephyr-rtos-driver/</id>
    <published>2018-04-23T22:13:28.000Z</published>
    <updated>2018-05-06T10:37:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>Итак в&nbsp;продолжение темы о&nbsp;драйверах для Zephyr переходим непосредственно к&nbsp;созданию конкретного драйвера устройства. В&nbsp;качестве подопытного я&nbsp;выбрал ИК&nbsp;термодатчик MLX90614.</p><span id="more"></span><p>Этот датчик я&nbsp;использовал в&nbsp;одной поделке&nbsp;&mdash; фактически это терморегулятор для одного устройства. Оно уже практически в&nbsp;рабочем состоянии, но&nbsp;делано было на&nbsp;ATmega8. В&nbsp;силу ряда причин хочу переделать на&nbsp;STM32. Это я&nbsp;собственно к&nbsp;тому, что драйвер будет не&nbsp;просто демонстрационным псевдокодом, а&nbsp;вполне конкретным куском кода, который я&nbsp;даже попробую протолкнуть в&nbsp;основную ветку кода зефира.</p><h1 id="Железо"><a href="#Железо" class="headerlink" title="Железо"></a>Железо</h1><p>В качестве тестового железа будет использована стандартная BLE400 с&nbsp;микроконтроллером nRF51822&nbsp;на&nbsp;борту. Для программирования возьму пожалуй JLink. Ну&nbsp;и&nbsp;для отладки пригодится логический анализатор.</p><h1 id="Возможности-датчика"><a href="#Возможности-датчика" class="headerlink" title="Возможности датчика"></a>Возможности датчика</h1><p>Для создания полноценного драйвера нам необходимо вычленить из&nbsp;спецификации какие есть варианты и&nbsp;опции у&nbsp;нашего устройства, чтобы вынести их&nbsp;в&nbsp;опции драйвера. Так-же нужно определиться с&nbsp;протоколом обмена данными. В&nbsp;общем смотрим спецификацию.</p><p>Итак существуют разные вариации этого датчика. Конкретный вариант задаётся маркировкой на&nbsp;корпусе. Типа <code>MLX90614ESF-BAA-000-TU</code>. Нас интересует первая буква после названия датчика&nbsp;&mdash; в&nbsp;данном случае <code>E</code>, а&nbsp;так-же две первые буквы трёхбуквенного кода в&nbsp;середине (BAA), т.&nbsp;к.&nbsp;они влияют на&nbsp;характеристики устройства (напряжение питания и&nbsp;количество термоэлементов). Видимо их&nbsp;придётся выносить в&nbsp;настройки. Но&nbsp;не&nbsp;факт&nbsp;&mdash; просто отложим это в&nbsp;памяти.</p><p>Мой экземпляр кстати какой-то вообще никакой&nbsp;&mdash; маркировка совсем непонятная <code>B89736X16E</code>. Единственную информацию по&nbsp;ней нашёл на&nbsp;китайском форуме, да&nbsp;и&nbsp;то&nbsp;это обсуждение типа &laquo;кто-нибудь знает, что за&nbsp;маркировка?&raquo;. Пытался найти где я&nbsp;его купил, но&nbsp;тщетно&nbsp;&mdash; эта информация уже канула в&nbsp;лету. Но&nbsp;на&nbsp;нём есть буковка <code>B</code> из&nbsp;чего я&nbsp;могу сделать вывод, что это датчик с&nbsp;3-х вольтовым питанием. Хотя судя по&nbsp;спецификации и&nbsp;5&nbsp;вольт для него не&nbsp;являются смертельными. В&nbsp;итоге это предположение оказалось верным.</p><p>Данные передаются либо через SMBus либо через&nbsp;PWM. Есть режим термо-реле, когда задаётся температурный диапазон, а&nbsp;датчик подаёт сигнал только когда температура выходит за&nbsp;заданные границы. Режим работы измерение/реле, а&nbsp;так-же режим передачи данных мы&nbsp;тоже вынесем в&nbsp;настройки драйвера.</p><p>Ага! Читаем спецификацию далее и&nbsp;видим, что устройство управляется записью данных в&nbsp;EEPROM с&nbsp;помощью SMbus. Нам доступно 32 2-х байтных слова. Но&nbsp;большинство из&nbsp;них не&nbsp;используются. Так-же есть RAM с&nbsp;доступом только на&nbsp;чтение 32 17-ти битных слова.</p><p>Ну что&nbsp;&mdash; будем разбираться. В&nbsp;общем SMBus у&nbsp;нас штука обязательная, а&nbsp;вот режим PWM&nbsp;&mdash; опциональный. Поддержка SMBus кстати урезанная&nbsp;&mdash; поддерживаются только 2&nbsp;команды&nbsp;&mdash; записать слово и&nbsp;прочитать слово. Частота работы шины от&nbsp;10&nbsp;до&nbsp;100&nbsp;кГц.</p><p>Итак у&nbsp;нас вырисовываются следующие настройки:</p><ul><li>Режим работы SMBUS/PWM/RELAY</li><li>Число сенсоров 1&nbsp;или 2</li><li>Напряжение питания 5В или 3В (от этого зависят некоторые функции) </li></ul><p>Но в&nbsp;итоге забегая вперёд скажу, что пока для демонстрации решил ограничиться минимальным набором&nbsp;&mdash; считывание температуры через SMBus. Для демонстрации и&nbsp;для моих целей этого пока достаточно, а&nbsp;будет настроение добавить функционала никогда не&nbsp;поздно.</p><h1 id="Каков-дальнейший-план"><a href="#Каков-дальнейший-план" class="headerlink" title="Каков дальнейший план?"></a>Каков дальнейший план?</h1><p>Очевидно, что работа датчика сильно завязана на&nbsp;SMBus. Но&nbsp;как мы&nbsp;знаем SMBus и&nbsp;I<sup>2</sup>C близнецы-браться, поэтому попытаемся использовать для коммуникации с&nbsp;датчиком возможности I<sup>2</sup>C, тем более, что контроллер, выбранный для разработки имеет аппаратную поддержку этого протокола.</p><p>Ну и&nbsp;следующий шаг&nbsp;&mdash; сборка тестового макета, создание заготовки драйвера и&nbsp;написание тестового приложения для чтения и&nbsp;отображения температуры с&nbsp;датчика. В&nbsp;общем всё просто.</p><h1 id="Собираем-стенд"><a href="#Собираем-стенд" class="headerlink" title="Собираем стенд"></a>Собираем стенд</h1><p>В общем для экспериментов выбрал плату BLE400, к&nbsp;которой подключил брэдборд с&nbsp;датчиком, ну&nbsp;и&nbsp;к&nbsp;ним подцепил JLink и&nbsp;анализатор SaleaLogic (он у&nbsp;меня без корпуса ибо китайский корпус развалился в&nbsp;первый&nbsp;же&nbsp;день&nbsp;&mdash; какой стыд). Ну&nbsp;и&nbsp;для экономии на&nbsp;проводах (чтоб не&nbsp;тянуть к&nbsp;ноутбуку этот клубок проводов)  всё это подключено через USB хаб специально купленными огрызками USB кабелей. Получилось как-то&nbsp;так:</p><img src="/2018/04/24/writing-mlx90614-zephyr-rtos-driver/IMG_20180505_233744.jpg" class="" title="Рабочий макет для отладки датчика"><p>Распиновка датчика&nbsp;&mdash; в&nbsp;спецификации схема указана не&nbsp;совсем однозначно, поэтому приведу здесь более понятное фото:</p><img src="/2018/04/24/writing-mlx90614-zephyr-rtos-driver/mlx-package.jpg" class="" title="Распиновка MLX90614"><p>Сам датчик тупо воткнул ногами в&nbsp;разъёмы соединительных проводов, предварительно напаяв на&nbsp;него более толстые ножки от&nbsp;гребёнок (он был раньше в&nbsp;плате, распаян через преобразователь уровня&nbsp;т.&nbsp;к.&nbsp;предыдущая поделка питалась от&nbsp;5В, а&nbsp;датчик 3-х вольтовый ну&nbsp;и&nbsp;соответственно ножки коротковаты).</p><img src="/2018/04/24/writing-mlx90614-zephyr-rtos-driver/IMG_20180505_234253.jpg" class="" title="Подключение MLX90614"><h1 id="Итог"><a href="#Итог" class="headerlink" title="Итог"></a>Итог</h1><p>Пока решил эту статью закончить и&nbsp;перейти к&nbsp;программированию уже в&nbsp;следующей&nbsp;&mdash; как-то много набирается материала и&nbsp;не&nbsp;хочется всё пихать в&nbsp;одну кучу&nbsp;&mdash; и&nbsp;так статья получилась несколько сумбурной. В&nbsp;общем в&nbsp;итоге определился что делать и&nbsp;как, собрал всё железо&nbsp;&mdash; далее перейдём уже ближе к&nbsp;делу.</p><h1 id="Источники"><a href="#Источники" class="headerlink" title="Источники"></a>Источники</h1><ul><li><a href="https://www.melexis.com/en/product/MLX90614/Digital-Plug-Play-Infrared-Thermometer-TO-Can">https://www.melexis.com/en/product/MLX90614/Digital-Plug-Play-Infrared-Thermometer-TO-Can</a></li><li><a href="https://geektimes.com/post/285226/">https://geektimes.com/post/285226/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Итак в продолжение темы о драйверах для Zephyr переходим непосредственно к созданию конкретного драйвера устройства. В качестве подопытного я выбрал ИК термодатчик MLX90614.&lt;/p&gt;</summary>
    
    
    
    <category term="programming" scheme="https://diytronic.ru/categories/programming/"/>
    
    
    <category term="zephyr" scheme="https://diytronic.ru/tags/zephyr/"/>
    
    <category term="drivers" scheme="https://diytronic.ru/tags/drivers/"/>
    
    <category term="MLX90614" scheme="https://diytronic.ru/tags/MLX90614/"/>
    
    <category term="smbus" scheme="https://diytronic.ru/tags/smbus/"/>
    
    <category term="i2c" scheme="https://diytronic.ru/tags/i2c/"/>
    
    <category term="PWM" scheme="https://diytronic.ru/tags/PWM/"/>
    
  </entry>
  
  <entry>
    <title>Пишем драйвер устройства для Zephyr RTOS</title>
    <link href="https://diytronic.ru/2018/04/14/writing-zephyr-rtos-device-driver/"/>
    <id>https://diytronic.ru/2018/04/14/writing-zephyr-rtos-device-driver/</id>
    <published>2018-04-13T23:07:59.000Z</published>
    <updated>2018-04-26T07:54:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>Я тут боле-менее разобрался с&nbsp;написанием драйверов для Zephyr-а. Решил поделиться своим опытом. Информации об&nbsp;этом не&nbsp;так, чтобы очень много, поэтому думаю кому-то это может пригодиться. Если вам эта тема интересна, то&nbsp;значит вы&nbsp;попали по&nbsp;адресу.</p><span id="more"></span><h1 id="Как-использовать-драйвер-в-коде"><a href="#Как-использовать-драйвер-в-коде" class="headerlink" title="Как использовать драйвер в коде"></a>Как использовать драйвер в&nbsp;коде</h1><p>Для начала, чтоб понять вообще что мы&nbsp;делаем давайте разберёмся как вызвать драйвер в&nbsp;коде приложения. Для примера приведу некий псевдокод. Пусть это будет драйвер светодиода, API которого будет состоять из&nbsp;методов <code>led_on</code>, <code>led_off</code> без параметров и&nbsp;<code>toggle</code> с&nbsp;булевым параметром означающим состояние светодиода.</p><pre class="code language language-c"><code class="language language-c"><span class="token comment">/* подключаем описание API драйвера */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"led_driver_api.h"</span>;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">/* получаем указатель на конфигурацию драйвера */</span>    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev <span class="token operator">=</span> <span class="token function">device_get_binding</span><span class="token punctuation">(</span><span class="token string">"LED-DRIVER"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* получаем ссылку на API драйвера*/</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">led_driver_api</span> <span class="token operator">*</span>api <span class="token operator">=</span> dev<span class="token operator">-></span>driver_api<span class="token punctuation">;</span>    <span class="token comment">/* вызываем доступные драйверу методы API */</span>    api<span class="token operator">-></span><span class="token function">led_on</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    api<span class="token operator">-></span><span class="token function">toggle</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Зачем так сложно и&nbsp;почему просто не&nbsp;подёргать светодиод обращаясь к&nbsp;портам напрямую? Если проект невелик, то&nbsp;вопрос вполне резонный и&nbsp;я&nbsp;даже отвечу, что вы&nbsp;правы&nbsp;&mdash; ни&nbsp;к&nbsp;чему такое усложнение. Но&nbsp;если проект довольно сложный то&nbsp;очень легко получить конфликтную или ошибочную ситуацию да&nbsp;и&nbsp;просто запутаться в&nbsp;коде.</p><p>В частности это позволяет избежать одновременного доступа к&nbsp;пинам из&nbsp;разных мест программы, что вполне возможно когда несколько устройств сидят например на&nbsp;одних и&nbsp;тех-же выводах используя шину i2c. Код отвечающий за&nbsp;разные устройства может запросто начать одновременно пытаться сформировать нужные сигналы на&nbsp;линии, тем самым мешая друг другу.</p><p>Использование драйвера позволяет изолировать код непосредственного доступа к&nbsp;пинам внутри драйвера. Операционная система&nbsp;же&nbsp;в&nbsp;свою очередь гарантирует изоляцию разрешая непосредственно приложению лишь доступные вызовы API методов. Кроме того добивается переносимость кода. Например для кода различного рода датчиков, когда достаточно подключить драйвер и&nbsp;пользоваться, не&nbsp;парясь особо над кодом и&nbsp;не&nbsp;адаптируя чужие куски кода для своей программы.</p><h1 id="А-на-каком-выводе-контроллера-зажжётся-светодиод"><a href="#А-на-каком-выводе-контроллера-зажжётся-светодиод" class="headerlink" title="А на каком выводе контроллера зажжётся светодиод?"></a>А на&nbsp;каком выводе контроллера зажжётся светодиод?</h1><p>В вышеприведённом коде совершенно неясно на&nbsp;какой-же ноге зажжётся светодиод. Как-же быть? Есть варианты.</p><h2 id="Захардкодить-прямо-в-драйвере"><a href="#Захардкодить-прямо-в-драйвере" class="headerlink" title="Захардкодить прямо в драйвере"></a>Захардкодить прямо в&nbsp;драйвере</h2><p>Тупейший метод&nbsp;&mdash; прошить нужный пин жестко в&nbsp;драйвере и&nbsp;пусть разработчик просто вешает всё на&nbsp;нужные выводы. Несмотря на&nbsp;кажущуюся глупость метод вполне имеет право на&nbsp;жизнь. Некоторые контроллеры например имеют аппаратную поддержку некоторых функций и&nbsp;только на&nbsp;определённых пинах. Ну&nbsp;например АЦП может быть только на&nbsp;определённой ноге. И&nbsp;тут уже ограничение накладывается именно железом, а&nbsp;не&nbsp;прихотями разработчика драйвера.</p><h2 id="Добавить-метод-в-API"><a href="#Добавить-метод-в-API" class="headerlink" title="Добавить метод в API"></a>Добавить метод в&nbsp;API</h2><p>Вполне себе тоже метод&nbsp;&mdash; просто в&nbsp;API добавляем нужный метод типа <code>set_pin(dev, &lt;номер вывода&gt;)</code> и&nbsp;драйвер будет использовать эти данные для работы.</p><p>Так-же для хранения неких конфигурационных данных в&nbsp;структуре <code>device *dev</code> в&nbsp;коде выше есть поле <code>config</code>. У&nbsp;каждого драйвера там хранится своя информация, поэтому чтобы знать, что и&nbsp;куда там складывать нужно изучить заголовочный файл драйвера и&nbsp;поискать информацию&nbsp;там.</p><pre class="code language language-c"><code class="language language-c"><span class="token comment">/* подключаем описание API драйвера */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"led_driver_api.h"</span>;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">/* получаем указатель на конфигурацию драйвера */</span>    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev <span class="token operator">=</span> <span class="token function">device_get_binding</span><span class="token punctuation">(</span><span class="token string">"LED-DRIVER"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dev<span class="token operator">-></span>config<span class="token operator">-></span>pin <span class="token operator">=</span> <span class="token operator">&lt;</span>номер пина<span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// тут прописывам нужный пин</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>Но это в&nbsp;большей степени&nbsp;хак, чем нормальный&nbsp;код. При достаточно сложном проекте раскиданные по&nbsp;коду настройки конфигурации лишь усложнят жизнь. Поэтому плавно переходим к&nbsp;правильному способу.</p><h2 id="Прописать-в-файл-настроек-приложения"><a href="#Прописать-в-файл-настроек-приложения" class="headerlink" title="Прописать в файл настроек приложения"></a>Прописать в&nbsp;файл настроек приложения</h2><p>Zephyr поддерживает систему конфигурирования Kconfig, используемую так-же в&nbsp;частности ядром Linux. Фактически это некий файл конфигурации, состоящих из&nbsp;набора переменных <code>ключ</code> =&gt; <code>значение</code>. Во&nbsp;время сборки все они подставляются в&nbsp;код в&nbsp;виде переменных. Очевидно, что в&nbsp;случае большого проекта количество переменных будет довольно большим и&nbsp;управлять ими будет сложно, поэтому система Kconfig имеет графический интерфейс для управления этими переменными.</p><img src="/2018/04/14/writing-zephyr-rtos-device-driver/Kconfig-screen.png" class="" title="Пример окна Kconfig"><p>Собственно настройка проекта через Kconfig и&nbsp;является наиболее кошерным методом настройки проекта. В&nbsp;данном примере мы&nbsp;как раз видим опции драйвера DHT11/22. Тут как раз можно во&nbsp;первых включить в&nbsp;код поддержку данного драйвера (в данном случае это была галочка на&nbsp;предыдущем экране), выбрать GPIO, номер порта, имя драйвера и&nbsp;т.&nbsp;п.</p><p>После сохранения файла у&nbsp;нас появится файл с&nbsp;настройками, в&nbsp;котором можно посмотреть названия переменных. Нам собственно интересна переменная с&nbsp;именем драйвера, чтобы не&nbsp;зависеть от&nbsp;этой строки. В&nbsp;данном случае это будет переменная <code>CONFIG_DHT_NAME</code> и&nbsp;наш код будет выглядеть следующим образом:</p><pre class="code language language-c"><code class="language language-c"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">/* получаем указатель на конфигурацию драйвера */</span>    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev <span class="token operator">=</span> <span class="token function">device_get_binding</span><span class="token punctuation">(</span>CONFIG_DHT_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Ну вот в&nbsp;целом и&nbsp;всё про использование драйверов. Подробнее про каждый драйвер можно узнать изучив исходники в&nbsp;папке <code>drivers</code> кода Zephyr RTOS. Там есть и&nbsp;API и&nbsp;опции Kconfig. Ну,&nbsp;а&nbsp;в&nbsp;готовом проекте уже можно поднастроить какие-то опции драйвера из&nbsp;графической оболочки.</p><p>В следующей статье начну писать конкретный драйвер устройства ну&nbsp;и&nbsp;покажу на&nbsp;примере как это делается.</p>]]></content>
    
    
    <summary type="html">Как написать дравер для Zephyr RTOS? Базовые понятия.</summary>
    
    
    
    <category term="programming" scheme="https://diytronic.ru/categories/programming/"/>
    
    
    <category term="zephyr" scheme="https://diytronic.ru/tags/zephyr/"/>
    
    <category term="rtos" scheme="https://diytronic.ru/tags/rtos/"/>
    
    <category term="drivers" scheme="https://diytronic.ru/tags/drivers/"/>
    
    <category term="c-lang" scheme="https://diytronic.ru/tags/c-lang/"/>
    
    <category term="programming" scheme="https://diytronic.ru/tags/programming/"/>
    
  </entry>
  
  <entry>
    <title>Апгрейд китайского БП с 5 до 12 вольт</title>
    <link href="https://diytronic.ru/2018/04/07/upgrade-5v-power-supply-to-12v/"/>
    <id>https://diytronic.ru/2018/04/07/upgrade-5v-power-supply-to-12v/</id>
    <published>2018-04-07T14:47:47.000Z</published>
    <updated>2018-04-07T14:49:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>В одной из&nbsp;поделок понадобилось питание порядка 12-15&nbsp;вольт. Как и&nbsp;у&nbsp;многих наверно дома валяется куча блоков питания от&nbsp;старых мобильников. Но&nbsp;все они как правило 5-ти вольтовые. Решил доработать один из&nbsp;таких блоков и&nbsp;поднять ему напряжение до&nbsp;требуемого.</p><span id="more"></span><p>Как правило все современные блоки питания являются импульсными, что с&nbsp;одной стороны уменьшает их&nbsp;размер, но&nbsp;с&nbsp;другой стороны достигается это некоторым усложнением схемотехники.</p><h1 id="Пациент"><a href="#Пациент" class="headerlink" title="Пациент"></a>Пациент</h1><p>Не заснял этот блок питания в&nbsp;оригинальном корпусе, да&nbsp;наверно это и&nbsp;не&nbsp;важно&nbsp;&mdash; обычный чёрный пластиковый корпус с&nbsp;вилкой.</p><p>Снизу плата выглядит вот так</p><p><img src="20151122_124818.jpg" alt="Плата вид снизу"></p><p>А это вид на&nbsp;монтаж</p><p><img src="20151122_124852.jpg" alt="Вид на монтаж"></p><p>Невооружённым взглядом виден классический импульсный&nbsp;БП.</p><h1 id="Увеличиваем-напряжение-с-делителя"><a href="#Увеличиваем-напряжение-с-делителя" class="headerlink" title="Увеличиваем напряжение с делителя"></a>Увеличиваем напряжение с&nbsp;делителя</h1><p>Первое что пришло в&nbsp;голову увеличить напряжение в&nbsp;цепи обратной связи регулятора. Для этого как минимум нужно было найти на&nbsp;плате делитель. Вот собственно&nbsp;он.</p><p><img src="2015-11-22-130109.jpg" alt="Резисторы делителя в цепи обратной связи"></p><p>Нижний резистор делителя 4.9&nbsp;кОм был заменен на&nbsp;подстроечный номиналом 10&nbsp;кОм.&nbsp;Монтаж конечно неказистый, но&nbsp;это времянка и&nbsp;с&nbsp;требуемой задачей вполне справляется.</p><p><img src="20151122_174535.jpg" alt="Попытка порегулировать напряжение в цепи обртной связи"></p><p>Не прокатило&nbsp;&mdash; напряжение удалось поднять максимум до&nbsp;8&nbsp;вольт. При этом блок питания начал отчаянно пищать, что как&nbsp;бы&nbsp;намекало&nbsp;нам, что режим работы далёк от&nbsp;оптимального.</p><p>Дальнейшее насилие я&nbsp;посчитал бессмысленным и&nbsp;решил копнуть глубже.</p><h1 id="Перемотка-трансформатора"><a href="#Перемотка-трансформатора" class="headerlink" title="Перемотка трансформатора"></a>Перемотка трансформатора</h1><p>Трансформатор был выпаян из&nbsp;платы. Надежда на&nbsp;безболезненное удаление сердечника не&nbsp;оправдалась&nbsp;&mdash; легко вышла лишь одна половинка, а&nbsp;вторая была приклеена к&nbsp;катушке с&nbsp;обмотками каким-то компаундом и&nbsp;я&nbsp;не&nbsp;решился её&nbsp;отодрать, т.&nbsp;к.&nbsp;боялся повредить хрупкий сердечник. Тем не&nbsp;менее даже в&nbsp;таком виде удалось довольно легко снять изоляцию обмоток и&nbsp;обнажить первую обмотку. Как оказалось это была регулирующая обмотка, а&nbsp;мне была нужна вторичная.</p><p><img src="20151122_140718.jpg" alt="Трансформатор без изоляции - видна регулирующая обмотка"></p><p>Пришлось смотать эту обмотку, после чего обнажилась вторичная обмотка, которая состояла из&nbsp;10&nbsp;витков медного провода диаметром 0,6&nbsp;мм, намотанным в&nbsp;2&nbsp;жилы.</p><p><img src="20151122_155125.jpg" alt="Разобранный трансформатор - видна вторичная обмотка"></p><p>Т.к. мне требовалось поднять напряжение примерно в&nbsp;2&nbsp;раза я&nbsp;домотал еще 12&nbsp;витков. Хотя как уже подумал позже можно было ничего не&nbsp;доматывать и&nbsp;просто разделить жилы обмотки и&nbsp;таким образом удвоить их&nbsp;число. Мощность-то у&nbsp;нас всё равно не&nbsp;изменилась и&nbsp;ограничивается сечением сердечника трансформатора, а&nbsp;увеличив напряжение в&nbsp;2&nbsp;раза максимальный ток соответственно уменьшился в&nbsp;2&nbsp;раза и&nbsp;можно было&nbsp;бы&nbsp;обойтись проводом вдвое меньшего сечения. Но&nbsp;как говорится&nbsp;&mdash; &laquo;хорошая мысля приходит опосля&raquo;.</p><p>Итого в&nbsp;результате после домотки нужного количества витков и&nbsp;возвращения обратно регулирующей обмотки получилась вот такая конструкция.</p><p><img src="20151122_161844.jpg" alt="Трансформатор после апгрейда в сборе"></p><p>Ну, а&nbsp;далее трансформатор был возвращён на&nbsp;плату.</p><p>Подстроечным резистором регулятора легко удалось получить требуемые 12&nbsp;вольт. Бонусом получил исчезновение даже того небольшого свиста который был у&nbsp;этого блока питания до&nbsp;переделки. Ну&nbsp;и&nbsp;далее уже всё просто&nbsp;&mdash; подстроечник был заменён на&nbsp;постоянный резистор и&nbsp;всё окончательно превратилось в&nbsp;конфетку.</p><p>Вот как-то так можно использовать старый хлам в&nbsp;своих поделках.</p><p>PS: На&nbsp;самом деле сделано ещё в&nbsp;2015&nbsp;году&nbsp;&mdash; только дошли руки дописать: ) </p>]]></content>
    
    
    <summary type="html">Как повысить напряжение старого 5-вольтового блока питания до 12 вольт.</summary>
    
    
    
    <category term="electronics" scheme="https://diytronic.ru/categories/electronics/"/>
    
    
    <category term="power-supply" scheme="https://diytronic.ru/tags/power-supply/"/>
    
    <category term="howto" scheme="https://diytronic.ru/tags/howto/"/>
    
  </entry>
  
  <entry>
    <title>Мигаем светодиодом через Bluetooth</title>
    <link href="https://diytronic.ru/2018/03/12/led-blinking-throuth-ble/"/>
    <id>https://diytronic.ru/2018/03/12/led-blinking-throuth-ble/</id>
    <published>2018-03-12T17:40:46.000Z</published>
    <updated>2018-03-15T16:05:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>В одном из&nbsp;комментариев меня упрекнули&nbsp;&mdash; дескать &laquo;всё суета, а&nbsp;ты&nbsp;вот попробуй светодиодом поморгать через bluetooth&raquo;. Ну&nbsp;что&nbsp;&mdash; упрёк справедлив и&nbsp;вызов принят. Начинаю серию статей по&nbsp;программированию под zephyr. В&nbsp;данной статье будет код для bluetooth устройства с&nbsp;одним светодиодом, которым можно управлять.</p><span id="more"></span><p>Я слегка напряжён&nbsp;&mdash; каждый раз когда громко заявляю про серию статей возникают обстоятельства непреодолимой силы, по&nbsp;которым каждый раз эта серия заканчивается на&nbsp;первой&nbsp;же&nbsp;статье. Но&nbsp;тем-не менее попробую.</p><h1 id="Создаём-минимальное-bluetooth-устройство"><a href="#Создаём-минимальное-bluetooth-устройство" class="headerlink" title="Создаём минимальное bluetooth устройство"></a>Создаём минимальное bluetooth устройство</h1><p>Итак простейший код для включения bluetooth является просто вызовом функции <code>bt_enable</code> в&nbsp;которую передаётся функция которая вызовется после завершения инициализации bluetooth стека. В&nbsp;этой функции мы&nbsp;вызываем функцию <code>bt_le_adv_start</code> в&nbsp;которую передаём данные для адвертайзинга и&nbsp;для сканирования.</p><p>Вот такого кода вполне достаточно для создания BLE устройства. Я&nbsp;сознательно удалил все проверки на&nbsp;ошибки и&nbsp;вызовы отладочных функций, чтобы не&nbsp;загромождать код и&nbsp;чтобы было более понятно. На&nbsp;самом деле конечно проверка кодов ошибок возвращаемых функциями нужна.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zephyr.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bluetooth/bluetooth.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bluetooth/hci.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME<span class="string">&quot;Zephyr LED test&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME_LEN(sizeof(DEVICE_NAME) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bt_data</span> <span class="title">ad</span>[] =</span> &#123;</span><br><span class="line">  BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Имя видимое при сканированиии</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bt_data</span> <span class="title">sd</span>[] =</span> &#123;</span><br><span class="line">  BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Функция вызываемая по завершении инициализации bluetooth</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">bt_ready</span><span class="params">(<span class="type">int</span> err)</span></span><br><span class="line">&#123;</span><br><span class="line">  bt_le_adv_start(BT_LE_ADV_CONN, ad, ARRAY_SIZE(ad), sd, ARRAY_SIZE(sd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  bt_enable(bt_ready);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Собственно запустив вот такой нехитрый код на&nbsp;устройстве мы&nbsp;получаем вполне рабочее bluetooth устройство</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ bluetoothctl</span><br><span class="line">....</span><br><span class="line">[NEW] Device EE:DC:1F:BE:87:F0 Zephyr LED <span class="built_in">test</span></span><br><span class="line">Agent registered</span><br><span class="line"></span><br><span class="line">[bluetooth]<span class="comment"># info EE:DC:1F:BE:87:F0</span></span><br><span class="line">Device EE:DC:1F:BE:87:F0 (random)</span><br><span class="line">Name: Zephyr LED <span class="built_in">test</span></span><br><span class="line">Alias: Zephyr LED <span class="built_in">test</span></span><br><span class="line">Appearance: 0x0341</span><br><span class="line">Paired: no</span><br><span class="line">Trusted: no</span><br><span class="line">Blocked: no</span><br><span class="line">Connected: no</span><br><span class="line">LegacyPairing: no</span><br><span class="line">UUID: Generic Access Profile    (00001800-0000-1000-8000-00805f9b34fb)</span><br><span class="line">UUID: Generic Attribute Profile (00001801-0000-1000-8000-00805f9b34fb)</span><br><span class="line"></span><br><span class="line">[bluetooth]<span class="comment"># connect EE:DC:1F:BE:87:F0</span></span><br><span class="line">Attempting to connect to EE:DC:1F:BE:87:F0</span><br><span class="line">[CHG] Device EE:DC:1F:BE:87:F0 Connected: <span class="built_in">yes</span></span><br><span class="line">Connection successful</span><br><span class="line">[CHG] Device EE:DC:1F:BE:87:F0 ServicesResolved: <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><h1 id="Минутка-теории"><a href="#Минутка-теории" class="headerlink" title="Минутка теории"></a>Минутка теории</h1><p>Вообще когда начинаешь разбираться с&nbsp;работой bluetooth стека документация выглядит откровенно пугающей. Куча терминов&nbsp;&mdash; все эти&nbsp;HCI, GATT, Advertizing и&nbsp;пр.&nbsp;по&nbsp;крайней мере мне так точно просто выносили мозг и&nbsp;погружали в&nbsp;депрессию. Однако разобравшись как следует в&nbsp;теме всё оказалось не&nbsp;так пугающе.</p><p>Итак к&nbsp;нашему великому счастью все нюансы соединения за&nbsp;нас обрабатывает zephyr и&nbsp;это прекрасно. Поэтому останавливаться на&nbsp;этом больше не&nbsp;буду. Перейдём к&nbsp;более насущной теме&nbsp;&mdash; обмену данными.</p><p>Итак для обмена данными в&nbsp;bluetooth стеке есть такое понятие как GATT&nbsp;&mdash; некая таблица аттрибутов, которую мы&nbsp;можем читать и&nbsp;если разрешат то&nbsp;и&nbsp;писать. На&nbsp;самом деле это прекрасно&nbsp;&mdash; никакого бардака и&nbsp;всё чётенько. Читаем и&nbsp;пишем только то&nbsp;что можно и&nbsp;только в&nbsp;заранее отведённые места.</p><p>Ну и&nbsp;соответственно чтобы как-то организовать взаимодействие и&nbsp;обмен данными с&nbsp;нашим устройством мы&nbsp;должны в&nbsp;нём создать такую таблицу и&nbsp;добавить в&nbsp;неё некий аттрибут в&nbsp;который мы&nbsp;и&nbsp;будем писать. А&nbsp;уже устройство должно следить за&nbsp;значением этого аттрибута и&nbsp;как-то реагировать&nbsp;&mdash; в&nbsp;нашем случае поджигать или гасить светодиод.</p><p>Переходим от&nbsp;теории к&nbsp;практике</p><h1 id="Создаём-GATT-таблицу"><a href="#Создаём-GATT-таблицу" class="headerlink" title="Создаём GATT таблицу"></a>Создаём GATT таблицу</h1><p>Собственно даже по&nbsp;умолчанию у&nbsp;любого устройства есть GATT таблица (возможно это zephyr добавляет&nbsp;&mdash; я&nbsp;это не&nbsp;рыл). Как минимум в&nbsp;ней есть имя и&nbsp;appearance (что-то вроде некоевого типа устройства). Аттрибуты GATT таблицы группируются в&nbsp;сервисы&nbsp;&mdash; вот тут (<a href="https://www.bluetooth.com/specifications/gatt/services">https://www.bluetooth.com/specifications/gatt/services</a>)  можно посмотреть список стандартных сервисов и&nbsp;аттрибутов. Сервисы в&nbsp;свою очередь группируются в&nbsp;профили.</p><p>Соответственно я&nbsp;создам сервис с&nbsp;одним аттрибутом. Ну&nbsp;и&nbsp;все элементы GATT имеют свой идентификатор UUID. Часть из&nbsp;них зарезервирована, а&nbsp;остальные можно использовать по&nbsp;своему усмотрению. Для создания UUID-ов в&nbsp;Zephyr есть набор макросов. В&nbsp;частности для нашего случая создадим следующие:</p><figure class="highlight c"><figcaption><span>UUID-ы для сервиса и&nbsp;аттрибута</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">bt_uuid_128</span> <span class="title">led_service_uuid</span> =</span> BT_UUID_INIT_128(</span><br><span class="line">  <span class="number">0xf0</span>, <span class="number">0xde</span>, <span class="number">0xbc</span>, <span class="number">0x9a</span>, <span class="number">0x78</span>, <span class="number">0x56</span>, <span class="number">0x34</span>, <span class="number">0x12</span>,</span><br><span class="line">  <span class="number">0x78</span>, <span class="number">0x56</span>, <span class="number">0x34</span>, <span class="number">0x12</span>, <span class="number">0x78</span>, <span class="number">0x56</span>, <span class="number">0x34</span>, <span class="number">0x12</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">bt_uuid_128</span> <span class="title">led1_uuid</span> =</span> BT_UUID_INIT_128(</span><br><span class="line">  <span class="number">0xf1</span>, <span class="number">0xde</span>, <span class="number">0xbc</span>, <span class="number">0x9a</span>, <span class="number">0x78</span>, <span class="number">0x56</span>, <span class="number">0x34</span>, <span class="number">0x12</span>,</span><br><span class="line">  <span class="number">0x78</span>, <span class="number">0x56</span>, <span class="number">0x34</span>, <span class="number">0x12</span>, <span class="number">0x78</span>, <span class="number">0x56</span>, <span class="number">0x34</span>, <span class="number">0x12</span>);</span><br></pre></td></tr></table></figure><p>Далее в&nbsp;примере выше мы&nbsp;определяли массив <code>ad</code> для адвертайзера. В&nbsp;него нужно добавить UUID сервиса.</p><figure class="highlight c"><figcaption><span>Прописываем advertizing аттрибуты</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bt_data</span> <span class="title">ad</span>[] =</span> &#123;</span><br><span class="line">  BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)),</span><br><span class="line">  BT_DATA_BYTES(BT_DATA_UUID128_ALL,</span><br><span class="line">    <span class="number">0xf0</span>, <span class="number">0xde</span>, <span class="number">0xbc</span>, <span class="number">0x9a</span>, <span class="number">0x78</span>, <span class="number">0x56</span>, <span class="number">0x34</span>, <span class="number">0x12</span>,</span><br><span class="line">    <span class="number">0x78</span>, <span class="number">0x56</span>, <span class="number">0x34</span>, <span class="number">0x12</span>, <span class="number">0x78</span>, <span class="number">0x56</span>, <span class="number">0x34</span>, <span class="number">0x12</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Ну и&nbsp;в&nbsp;хук, который вызывается после инициализации bluetooth стека добавим инициализацию GATT.</p><figure class="highlight c"><figcaption><span>Регистрация GATT</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">bt_ready</span><span class="params">(<span class="type">int</span> err)</span></span><br><span class="line">&#123;</span><br><span class="line">  bt_le_adv_start(BT_LE_ADV_CONN, ad, ARRAY_SIZE(ad), sd, ARRAY_SIZE(sd));</span><br><span class="line">  bt_gatt_service_register(&amp;led_svc); <span class="comment">// вот это добавлено</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>А передаём мы&nbsp;в&nbsp;функцию <code>bt_gatt_service_register</code> как раз ссылку на&nbsp;нашу таблицу, на&nbsp;создании которой далее остановлюсь подробнее.</p><p>Итак создание таблицы аттрибутов (GATT)  выглядит&nbsp;так:</p><figure class="highlight c"><figcaption><span>Создание GATT таблицы</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">bt_gatt_attr</span> <span class="title">led_attrs</span>[] =</span> &#123;</span><br><span class="line">  <span class="comment">/* Vendor Primary Service Declaration */</span></span><br><span class="line">  BT_GATT_PRIMARY_SERVICE(&amp;led_service_uuid),</span><br><span class="line">  BT_GATT_CHARACTERISTIC(&amp;led1_uuid.uuid, BT_GATT_CHRC_READ | BT_GATT_CHRC_WRITE),</span><br><span class="line">  BT_GATT_DESCRIPTOR(&amp;led1_uuid.uuid, BT_GATT_PERM_READ_ENCRYPT | BT_GATT_PERM_WRITE_ENCRYPT,</span><br><span class="line">    read_led1,</span><br><span class="line">    write_led1,</span><br><span class="line">    &amp;led1_value)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Как видно из&nbsp;таблицы мы&nbsp;просто вызываем ряд макросов, в&nbsp;которые первым параметром передаём UUID, а&nbsp;затем набор параметров. Для сервиса у&nbsp;нас никаких параметров&nbsp;нет, у&nbsp;аттрибута (CHARACTERISTIC)  только задаём права доступа, включая запись конечно., а&nbsp;вот в&nbsp;DESCRIPTOR кроме всего прочего передаём адреса функций для чтения и&nbsp;для записи этого аттрибута, ну&nbsp;и&nbsp;последним параметром адрес переменной, в&nbsp;которой будет храниться значение аттрибута. Её&nbsp;надо заранее объявить, впрочем как и&nbsp;функции.</p><p>Сами функции большого интереса не&nbsp;представляют посмотреть их&nbsp;можно в&nbsp;полной версии кода программы.</p><p>Ну собственно и&nbsp;всё&nbsp;&mdash; теперь осталось засунуть в&nbsp;функцию записи аттрибута проверку его значения и&nbsp;установку пина светодиода в&nbsp;соответствующее значение. Установка пина и&nbsp;поджигание светодиода я&nbsp;думаю тоже не&nbsp;ахти как интересно, поэтому останавливаться на&nbsp;нём не&nbsp;буду.</p><h1 id="Проверка"><a href="#Проверка" class="headerlink" title="Проверка"></a>Проверка</h1><p>В общем заливаю программу в&nbsp;устройство. Для проверки можно <a href="/2018/03/11/testing-ble-device-from-linux/" title="использовать несколько способов">использовать несколько способов</a>, но&nbsp;я&nbsp;почему-то выбрал вариант со&nbsp;смартфона. Просто захотелось по&nbsp;быстрому проверить. Для каких-то боле менее автоматических тестов лучше конечно написать некий код на&nbsp;том-же python-е.</p><p>Использовал я&nbsp;нордиковскую программу &laquo;nRF Connect&raquo;. Итак смотрим как выглядит наше устройство:</p><img src="/2018/03/12/led-blinking-throuth-ble/zephyr-led-discover-small.png" class="" title="Zephyr в списке устройств"><p>Если нажать кнопку &laquo;Connect&raquo; то&nbsp;происходит подключение и&nbsp;мы&nbsp;можем прочитать список сервисов и&nbsp;аттрибутов:</p><img src="/2018/03/12/led-blinking-throuth-ble/zephyr-led-read-value-small.png" class="" title="Zephyr после подключения - список аттрибутов"><p>Виден наш сервис и&nbsp;аттрибут. Видны они как Unknown&nbsp;т.&nbsp;к.&nbsp;являются нестандартными. Так-же видно значение аттрибута и&nbsp;кнопочки для чтения и&nbsp;записи.</p><img src="/2018/03/12/led-blinking-throuth-ble/zephr-led-send-value-small.png" class="" title="Zephyr отправка значения аттрибута"><p>Ну и&nbsp;отправляя значение отличное от&nbsp;нуля (обязательно вводить 2&nbsp;знака, даже если у&nbsp;нас незначащий нуль)  мы&nbsp;видим как на&nbsp;плате загорается светодиод. Соответственно вводя нулевое значение мы&nbsp;гасим светодиод.</p><h1 id="Итоги"><a href="#Итоги" class="headerlink" title="Итоги"></a>Итоги</h1><p>В общем я&nbsp;конечно&nbsp;рад, что всё получилось. Оговорюсь ещё раз&nbsp;&mdash;&nbsp;код, приведённый выше это всего-лишь пример&nbsp;&mdash; там отсутствуют проверки на&nbsp;ошибки ну&nbsp;и&nbsp;организован он&nbsp;с&nbsp;целью сделать его как можно более наглядным, а&nbsp;не&nbsp;удобным надёжным и&nbsp;производительным.</p><p>Вообще так размышляя на&nbsp;тему стоило&nbsp;бы&nbsp;управление светодиодом и&nbsp;работу с&nbsp;bluetooth внести в&nbsp;разные процессы, а&nbsp;взаимодействие сделать в&nbsp;виде обмена сообщениями. Тем более, что пишем-то мы&nbsp;под RTOS, которая как раз под такие вещи и&nbsp;заточена. Но&nbsp;в&nbsp;данном случае и&nbsp;таааак сойдёт.</p><p>Так-же осталась нераскрыта тема авторизации для доступа к&nbsp;записи атрибута, которая делается довольно просто.</p><p>Хоте записать видео, но&nbsp;что-то как-то пока ума не&nbsp;приложу как в&nbsp;один кадр засунуть экран, устройство и&nbsp;смартфон.</p><h1 id="Полный-код-программы"><a href="#Полный-код-программы" class="headerlink" title="Полный код программы"></a>Полный код программы</h1><p>Ниже привожу полный код программы:</p><script src="//gist.github.com/2280a8e5756bc8cf922c0864c7085a82.js?file=main.c"></script><h1 id="Источники"><a href="#Источники" class="headerlink" title="Источники"></a>Источники</h1><ul><li><a href="https://www.safaribooksonline.com/library/view/getting-started-with/9781491900550/ch04.html">https://www.safaribooksonline.com/library/view/getting-started-with/9781491900550/ch04.html</a></li><li><a href="https://www.bluetooth.com/specifications/assigned-numbers/generic-access-profile">https://www.bluetooth.com/specifications/assigned-numbers/generic-access-profile</a></li><li><a href="https://www.silabs.com/community/wireless/bluetooth/knowledge-base.entry.html/2017/02/10/bluetooth_advertisin-hGsf">https://www.silabs.com/community/wireless/bluetooth/knowledge-base.entry.html/10.02.2017/bluetooth_advertisin-hGsf</a></li><li><a href="https://stackoverflow.com/questions/10243769/what-range-of-bluetooth-uuids-can-be-used-for-vendor-defined-profiles">https://stackoverflow.com/questions/10243769/what-range-of-bluetooth-uuids-can-be-used-for-vendor-defined-profiles</a></li><li><a href="https://devzone.nordicsemi.com/b/blog/posts/nrf-blinky-compatible-firmware-using-zephyr-blueto?CommentSortBy=CreatedDate&amp;CommentSortOrder=Ascending">https://devzone.nordicsemi.com/b/blog/posts/nrf-blinky-compatible-firmware-using-zephyr-blueto? CommentSortBy=CreatedDate&amp; CommentSortOrder=Ascending</a></li></ul>]]></content>
    
    
    <summary type="html">Как написать код Bluetooth устройства для управления светодиодом на Zephyr RTOS.</summary>
    
    
    
    <category term="uncategorized" scheme="https://diytronic.ru/categories/uncategorized/"/>
    
    
    <category term="bluetooth" scheme="https://diytronic.ru/tags/bluetooth/"/>
    
    <category term="zephyr" scheme="https://diytronic.ru/tags/zephyr/"/>
    
    <category term="ble" scheme="https://diytronic.ru/tags/ble/"/>
    
    <category term="nrf51822" scheme="https://diytronic.ru/tags/nrf51822/"/>
    
    <category term="rtos" scheme="https://diytronic.ru/tags/rtos/"/>
    
    <category term="gatt" scheme="https://diytronic.ru/tags/gatt/"/>
    
  </entry>
  
  <entry>
    <title>Настраиваем рабочее окружение для Zephyr OS</title>
    <link href="https://diytronic.ru/2018/02/19/setting-up-and-running-of-zephyr-os/"/>
    <id>https://diytronic.ru/2018/02/19/setting-up-and-running-of-zephyr-os/</id>
    <published>2018-02-19T15:38:14.000Z</published>
    <updated>2018-03-15T16:02:43.000Z</updated>
    
    <content type="html"><![CDATA[<a href="/2018/02/19/testing-and-reviewing-of-zephyr-os/" title="Начитавшись всякого про Zephyr OS">Начитавшись всякого про Zephyr OS</a> решил перейти к&nbsp;тестам. Мигать светодиодами посчитал ниже своего достоинства и&nbsp;решил сразу &laquo;зайти с&nbsp;козырей&raquo; и&nbsp;начать сразу с&nbsp;BLE примеров. Ну&nbsp;и&nbsp;самая классика это конечно BLE beacon. С&nbsp;него и&nbsp;начинаю.<span id="more"></span><h1 id="Ставим-ядро"><a href="#Ставим-ядро" class="headerlink" title="Ставим ядро"></a>Ставим ядро</h1><p>Итак для начала нам надо установить ядро Zephyr. Для этого создаём папку и&nbsp;клонируем туда код с&nbsp;GitHub.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> zephyr</span><br><span class="line">$ <span class="built_in">cd</span>  zephyr</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/zephyrproject-rtos/zephyr.git</span><br></pre></td></tr></table></figure><p>Потом переходим в&nbsp;скачанную папку с&nbsp;зефиром и&nbsp;ставим все зависимости. Для этого у&nbsp;нас должен быть установлен python версии 3. У&nbsp;меня оно уже стояло. На&nbsp;установке python останавливаться не&nbsp;буду.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd  zephyr</span><br><span class="line">$ pip3 install --user -r scripts/requirements.txt</span><br></pre></td></tr></table></figure><h1 id="Ставим-SDK"><a href="#Ставим-SDK" class="headerlink" title="Ставим SDK"></a>Ставим SDK</h1><p>SDK скачивается в&nbsp;виде самораспаковывающегося скрипта. В&nbsp;общем-то тут тоже всё довольно тривиально&nbsp;&mdash; качаем и&nbsp;запускаем. Оно спросит куда установить&nbsp;&mdash; я&nbsp;не&nbsp;стал спорить и&nbsp;дал ему установиться куда оно просило&nbsp;&mdash; в&nbsp;<code>/opt/zephyr-sdk</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://github.com/zephyrproject-rtos/meta-zephyr-sdk/releases/download/0.9.2/zephyr-sdk-0.9.2-setup.run</span><br><span class="line">$ sh zephyr-sdk-0.9.2-setup.run</span><br><span class="line">[sudo] пароль для roman:</span><br><span class="line">Verifying archive integrity... All good.</span><br><span class="line">Uncompressing SDK <span class="keyword">for</span> Zephyr  100%</span><br><span class="line">Enter target directory <span class="keyword">for</span> SDK (default: /opt/zephyr-sdk/):</span><br><span class="line">Installing SDK to /opt/zephyr-sdk</span><br><span class="line">Creating directory /opt/zephyr-sdk</span><br><span class="line">Success</span><br><span class="line"> [*] Installing x86 tools...</span><br><span class="line"> [*] Installing arm tools...</span><br><span class="line"> [*] Installing arc tools...</span><br><span class="line"> [*] Installing iamcu tools...</span><br><span class="line"> [*] Installing mips tools...</span><br><span class="line"> [*] Installing nios2 tools...</span><br><span class="line"> [*] Installing xtensa tools...</span><br><span class="line"> [*] Installing riscv32 tools...</span><br><span class="line"> [*] Installing additional host tools...</span><br><span class="line">Success installing SDK. SDK is ready to be used.</span><br></pre></td></tr></table></figure><p>Ну и&nbsp;для полного счастья нужно задать пару переменных окружения в&nbsp;конфиг зефира в&nbsp;домашней папке пользователя.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt; ~/.zephyrrc</span></span><br><span class="line"><span class="string">export ZEPHYR_TOOLCHAIN_VARIANT=zephyr</span></span><br><span class="line"><span class="string">export ZEPHYR_SDK_INSTALL_DIR=/opt/zephyr-sdk</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>Так-же наду куда-то в&nbsp;автозагрузку запихать скрипт из&nbsp;папки с&nbsp;ядром <code>zephyr-env.sh</code>. Он&nbsp;пропишет ещё какие-то свои пути и&nbsp;переменные. Я&nbsp;пока глубоко не&nbsp;рыл, но&nbsp;вроде там просто путь к&nbsp;файлам ядра указывается.</p><p>На этом&nbsp;всё. Можно приступать к&nbsp;сборке.</p><h1 id="Пробуем-собрать-проект"><a href="#Пробуем-собрать-проект" class="headerlink" title="Пробуем собрать проект"></a>Пробуем собрать проект</h1><p>Запускаю <code>zephyr-env.sh</code>&nbsp;&mdash; только ради переменной <code>$ZEPHYR_BASE</code>. Ну&nbsp;и&nbsp;переходим в&nbsp;папку с&nbsp;кодом для beacon-а.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> zephyr-env.sh</span><br><span class="line">$ <span class="built_in">cd</span> <span class="variable">$ZEPHYR_BASE</span>/samples/bluetooth/beacon</span><br></pre></td></tr></table></figure><p>Теперь нужно создать папку для своего проекта. Это фактически папка для сборки под конкретную железку. Для каждой железки под которую хочется собрать код нужно создавать свою. Я&nbsp;собираю код под <code>nrf51822</code> поэтому папку проекта обозвал как <code>nrf51</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build/nrf51 &amp;&amp; <span class="built_in">cd</span> build/nrf51</span><br></pre></td></tr></table></figure><p>По умолчанию сборка зефирных проектов выполняется с&nbsp;помощью <code>cmake</code> и&nbsp;<code>ninja</code>. CMake в&nbsp;этом случае только генерирует файлы для сборки, а&nbsp;ninja уже занимается сборкой, прошивкой и&nbsp;прочей грязной работой. Вообще можно организовать сборку и&nbsp;через make и&nbsp;в&nbsp;доках у&nbsp;зефира были описаны ещё варианты сборки, но&nbsp;я&nbsp;пока буду использовать&nbsp;то, что рекомендуют авторы проекта&nbsp;т.&nbsp;к.&nbsp;ожидаю, что те&nbsp;средства которые они используют и&nbsp;будут наиболее сьабильно работать.</p><p>Итак генерируем файлы для сборки&nbsp;&mdash; указываем, что сборка будет проводиться с&nbsp;помощью ninja и&nbsp;указываем конфигурацию используемой платы. В&nbsp;моём случае тестирую я&nbsp;только beacon и&nbsp;распиновка мне не&nbsp;важна, поэтому взял наугад какую-то плату под nrf51&nbsp;&mdash; <code>nrf51_pca10028</code>. Вот <a href="http://docs.zephyrproject.org/boards/arm/nrf51_pca10028/doc/nrf51_pca10028.html">тут</a> про неё поподробнее. Запускаем генерацию.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -GNinja -DBOARD=nrf51_pca10028 ../..</span><br><span class="line">-- Found PythonInterp: /usr/bin/python3 (found suitable version <span class="string">&quot;3.6.4&quot;</span>, minimum required is <span class="string">&quot;3.4&quot;</span>)</span><br><span class="line">-- Selected BOARD nrf51_pca10028</span><br><span class="line">Zephyr version: 1.10.99</span><br><span class="line">...</span><br><span class="line">-- Configuring <span class="keyword">done</span></span><br><span class="line">-- Generating <span class="keyword">done</span></span><br><span class="line">-- Build files have been written to: &lt;skip&gt;/beacon/build/nrf51</span><br></pre></td></tr></table></figure><p>Ну и&nbsp;запускаем сборку&nbsp;&mdash; просто стартуем ninja.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ninja</span><br><span class="line">[1/116] Generating always_rebuild</span><br><span class="line">Building <span class="keyword">for</span> board nrf51_pca10028</span><br><span class="line">[111/116] Linking C executable zephyr/zephyr_prebuilt.elf</span><br><span class="line">Memory region         Used Size  Region Size  %age Used</span><br><span class="line">           FLASH:       57032 B       256 KB     21.76%</span><br><span class="line">            SRAM:       12964 B        32 KB     39.56%</span><br><span class="line">        IDT_LIST:         132 B         2 KB      6.45%</span><br><span class="line">[116/116] Linking C executable zephyr/zephyr.elf</span><br></pre></td></tr></table></figure><p>Вроде мелочь, а&nbsp;приятно&nbsp;&mdash; ninja в&nbsp;итоге выдал некую статистическую сводку по&nbsp;использованию ресурсов контроллера. Кому&nbsp;как, а&nbsp;я&nbsp;люблю такие приятные мелочи.</p><p>Ну и&nbsp;та-дааам&nbsp;&mdash; заливаю прошивку в&nbsp;устройство. Получилось со&nbsp;2-го раза. Для работы с&nbsp;чипами nrf ninja пытается использовать утилиту <code>nrfjprog</code>, которая на&nbsp;самом деле ни&nbsp;что иное как SEGGER Jlink, только завёрнутый в&nbsp;их&nbsp;программу со&nbsp;своими ключами&nbsp;&mdash; ну&nbsp;типа всё заточено под nrf чипы. У&nbsp;меня она была просто скачана в&nbsp;отдельной папке&nbsp;&mdash; пришлось установить готовый пакет под мою&nbsp;OS.&nbsp;Как вариант можно было просто путь к&nbsp;nrfjprog прописать в&nbsp;системные пути. Но&nbsp;тем не&nbsp;менее дальше всё прошло абсолютно гладко.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ninja flash</span><br><span class="line">[1/84] Generating always_rebuild</span><br><span class="line">Building <span class="keyword">for</span> board nrf51_pca10028</span><br><span class="line">[1/2] Flashing nrf51_pca10028</span><br><span class="line">Flashing file: &lt;skip&gt;/build/nrf51/zephyr/zephyr.hex</span><br><span class="line">Erasing user available code and UICR flash areas.</span><br><span class="line">Applying system reset.</span><br><span class="line">Parsing hex file.</span><br><span class="line">Reading flash area to program to guarantee it is erased.</span><br><span class="line">Checking that the area to write is not protected.</span><br><span class="line">Programing device.</span><br><span class="line">Applying pin reset.</span><br><span class="line">Board with serial number 59400351 flashed successfully.</span><br></pre></td></tr></table></figure><p>После этого просканировал с&nbsp;телефона beacon-ы и&nbsp;обнаружил вот&nbsp;это:</p><img src="/2018/02/19/setting-up-and-running-of-zephyr-os/zephyr-beacon.png" class="" title="Beacon на Zephyr OS"><p>Более того. Андроид на&nbsp;телефоне сам нашёл bacon и&nbsp;запустил какое-то приложение Nearby, которое сказало мне что в&nbsp;радиусе 0,13&nbsp;метров от&nbsp;меня есть ссылка <code>www.zephyrproject.org</code>.</p><h1 id="Итоги-и-первые-впечатления"><a href="#Итоги-и-первые-впечатления" class="headerlink" title="Итоги и первые впечатления"></a>Итоги и&nbsp;первые впечатления</h1><p>В общем могу сказать, что Zephyr офигенен. Не&nbsp;хочу перегружать статью подробностями, но&nbsp;сам код маяка по&nbsp;сравнению с&nbsp;Mynewt гораздо понятнее и&nbsp;лаконичнее. В&nbsp;нём только именно&nbsp;то, что нужно без всякой лишней ерунды. И&nbsp;это при&nbsp;том, что в&nbsp;итоге получившийся маяк вышел гораздо функциональнее того, что удалось получить с&nbsp;Mynewt. Он&nbsp;сходу подхватился андроидом, в&nbsp;то&nbsp;время как Mynewt-оновский был виден только специальной программой.</p><p>Ну и&nbsp;опять&nbsp;же&nbsp;сравнивая с&nbsp;Mynewt&nbsp;&mdash; сборка примера прошла вообще без проблем. Ни&nbsp;одного мало-мальски значимого косяка с&nbsp;запуском кода или со&nbsp;сборкой. В&nbsp;общем Zephyr на&nbsp;голову выше Mynewt&nbsp;&mdash; совершенно другой уровень.</p><p>Буду изучать дальше. На&nbsp;самом деле доки я&nbsp;уже перечитал&nbsp;&mdash; там много вкусного и&nbsp;есть, что попробовать.</p><h1 id="Источники"><a href="#Источники" class="headerlink" title="Источники"></a>Источники</h1><ul><li><a href="https://www.youtube.com/watch?v=YNYamQ2qWE0">https://www.youtube.com/watch? v=YNYamQ2qWE0</a></li><li><a href="https://www.youtube.com/watch?v=H-rUGKCln0A">https://www.youtube.com/watch? v=H-rUGKCln0A</a></li><li><a href="https://www.youtube.com/watch?v=1NwNgY-Zs58">https://www.youtube.com/watch? v=1NwNgY-Zs58</a></li><li><a href="https://www.youtube.com/watch?v=iWhvK7DXv70">https://www.youtube.com/watch? v=iWhvK7DXv70</a></li><li><a href="http://docs.zephyrproject.org/boards/arm/nrf51_pca10028/doc/nrf51_pca10028.html">http://docs.zephyrproject.org/boards/arm/nrf51_pca10028/doc/nrf51_pca10028.html</a></li><li><a href="http://docs.zephyrproject.org/getting_started/getting_started.html">http://docs.zephyrproject.org/getting_started/getting_started.html</a></li></ul>]]></content>
    
    
    <summary type="html">Как настроить процесс сборки для Zephyr OS и запустить на ней тестовое приложение</summary>
    
    
    
    <category term="uncategorized" scheme="https://diytronic.ru/categories/uncategorized/"/>
    
    
    <category term="zephyr" scheme="https://diytronic.ru/tags/zephyr/"/>
    
    <category term="nrf51822" scheme="https://diytronic.ru/tags/nrf51822/"/>
    
    <category term="mynewt" scheme="https://diytronic.ru/tags/mynewt/"/>
    
    <category term="rtos" scheme="https://diytronic.ru/tags/rtos/"/>
    
    <category term="nrf51" scheme="https://diytronic.ru/tags/nrf51/"/>
    
    <category term="ble-beacon" scheme="https://diytronic.ru/tags/ble-beacon/"/>
    
  </entry>
  
  <entry>
    <title>Пробую на вкус Zephyr</title>
    <link href="https://diytronic.ru/2018/02/19/testing-and-reviewing-of-zephyr-os/"/>
    <id>https://diytronic.ru/2018/02/19/testing-and-reviewing-of-zephyr-os/</id>
    <published>2018-02-19T12:56:42.000Z</published>
    <updated>2018-02-28T18:28:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Что-то я&nbsp;как-то упоролся в&nbsp;конец RTOS-ами и&nbsp;что называется &laquo;Остапа понесло&raquo;. Обнаружил, что zephyr тоже поддерживает Bluetooth и&nbsp;решил попробовать как оно в&nbsp;работе. А&nbsp;копнув глубже обнаружил, что штука-то очень даже перспективная и&nbsp;имеет ряд довольно приятных возможностей и&nbsp;особенностей.</p><span id="more"></span><p>Как я&nbsp;выяснил Zephyr разрабатывается такими монстрами индустрии как Intel, Nordic, NXP, Texas Instruments и&nbsp;иже с&nbsp;ними, что как&nbsp;бы&nbsp;намекает&nbsp;нам, что разработка эта обречена на&nbsp;успех. Для сравнения Mynewt пилится непонятно кем и&nbsp;поддерживается похоже только Apache Foundation, что на&nbsp;особо радует. У&nbsp;зефира заявлено, что над проектом работает 218&nbsp;человек.</p><p>Сравнил репы zephyr и&nbsp;mynewt&nbsp;&mdash; у&nbsp;зефира разработка идёт гораздо бодрее. Ну&nbsp;и&nbsp;к&nbsp;слову отправлял в&nbsp;баг-трекер Mynewt сообщение о&nbsp;проблеме&nbsp;&mdash; уже несколько дней прошло и&nbsp;реакция нулевая, чему я&nbsp;не&nbsp;особо удивлён, т.&nbsp;к.&nbsp;изначально видел, что там и&nbsp;без меня достаточно репортов висящих без ответа.</p><p>У Zephyr есть поддержка IP&nbsp;стэка, что теоретически должно позволять нам объединять устройства в&nbsp;сеть и&nbsp;видимо даже общаться по&nbsp;сети с&nbsp;компьютерами. Есть поддержка Bluetooth, но&nbsp;пока только для нордиковских чипов. Но&nbsp;это вполне логично если учесть тот факт, что проект отчасти финансируется Nordic Semiconductors. К&nbsp;слову в&nbsp;документации к&nbsp;SDK у&nbsp;нордиков есть даже <a href="http://infocenter.nordicsemi.com/index.jsp?topic=/com.nordic.infocenter.whitepapers/dita/whitepapers/nwp_029/intro.html&cp=11_1">раздел, посвящённый Zephyr</a>.</p><p>В общем-то <a href="https://www.zephyrproject.org/what-is-zephyr/">цель разработки Zephyr</a> как заявлено у&nbsp;них на&nbsp;сайте довольно амбициозная&nbsp;&mdash; похоронить остальные&nbsp;оси, типа чтобы избежать фрагментации на&nbsp;этом поле.</p><p>Ну и&nbsp;ближе к&nbsp;делу&nbsp;&mdash; Zephyr генерирует монолитный код с&nbsp;единым адресным пространством ядра и&nbsp;приложения. Я&nbsp;пока не&nbsp;готов сказать хорошо это или плохо, но&nbsp;как минимум одно можно сказать точно&nbsp;&mdash; это удобно для разработки.</p><p>Концепция разработки Zephyr предполагает минимизировать использование ресурсов в&nbsp;процессе выполнения и&nbsp;перенести как можно больше на&nbsp;этап компиляции. Это касается как выделения ресурсов так и&nbsp;обработки ошибок, которая сведена к&nbsp;минимуму.</p><p>Ну и&nbsp;как уже писал выше встроенная поддержка сети, включая BLE меш сети. К&nbsp;слову в&nbsp;Mynewt это ещё в&nbsp;планах.</p><p>Минимальные системные требования&nbsp;&mdash; 8Кб памяти. Не&nbsp;нашёл правда какой&nbsp;&mdash; флеша или оперативки. Я&nbsp;почему-то думаю, что флеша.</p><p>Для сборки кода используется стандартный CMake. В&nbsp;общем-то это даже и&nbsp;неплохо&nbsp;&mdash; не&nbsp;надо осваивать никакие новые тулзы.</p><p>Нашёл у&nbsp;них в&nbsp;блоге ещё интересную штуку&nbsp;&mdash; можно разделить Bluetooth приложение между 2-мя чипами. Т.е. пишем один&nbsp;код, а&nbsp;запускаем часть на&nbsp;одном микроконтроллере (непосредственно приложение и&nbsp;Bluetooth host), а&nbsp;часть (Bluetooth controller)  на&nbsp;другом. Подробнее <a href="https://www.zephyrproject.org/building-a-qualified-ble-controller-with-zephyr-os-1-9/">тут</a>.</p><p>В общем однозначно надо пробовать этот зефир в&nbsp;работе&nbsp;&mdash; выглядит очень &laquo;вкусно&raquo;. Писанину пока закончу&nbsp;&mdash; накропал уже слишком много. Думаю надо перейти к&nbsp;практике, но&nbsp;об&nbsp;этом уже в&nbsp;следующий&nbsp;раз.</p>]]></content>
    
    
    <summary type="html">Делюсь первыми впечатлениями о Zephyr OS</summary>
    
    
    
    <category term="uncategorized" scheme="https://diytronic.ru/categories/uncategorized/"/>
    
    
    <category term="rtos" scheme="https://diytronic.ru/tags/rtos/"/>
    
    <category term="zephyr-os" scheme="https://diytronic.ru/tags/zephyr-os/"/>
    
  </entry>
  
  <entry>
    <title>iBeacon на Mynewt OS</title>
    <link href="https://diytronic.ru/2018/02/15/mynewt-testing-ibeacon-example/"/>
    <id>https://diytronic.ru/2018/02/15/mynewt-testing-ibeacon-example/</id>
    <published>2018-02-15T15:20:30.000Z</published>
    <updated>2018-02-15T16:49:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Воодушевившись первыми успехами с&nbsp;миганием светодиодами на&nbsp;Mynewt решил двинуть дальше и&nbsp;попробовать запустить BLE примеры с&nbsp;сайта. Простейший из&nbsp;них это конечно <a href="https://mynewt.apache.org/latest/os/tutorials/ibeacon/">BLE iBeacon</a>&nbsp;&mdash; его я&nbsp;и&nbsp;решил попробовать словив при этом несколько проблем.</p><span id="more"></span><p>Итак что меня есть: плата с&nbsp;nrf51822, программатор SEGGER Jlink, переходник UART -&gt; USB.</p><p>Создаём проект&nbsp;&mdash; ну&nbsp;в&nbsp;общем тут никакой магии:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> ibeacon-test</span><br><span class="line">$ <span class="built_in">cd</span> ibeacon-test</span><br><span class="line">$ newt new ibeakon                                                                                     2.4.2  8.1.3</span><br><span class="line">Downloading project skeleton from apache/mynewt-blinky...</span><br><span class="line">Installing skeleton <span class="keyword">in</span> ibeakon...</span><br><span class="line">Project ibeakon successfully created.</span><br><span class="line">$ <span class="built_in">cd</span> ibeacon</span><br><span class="line">$ newt install</span><br><span class="line">apache-mynewt-core successfully installed version 1.3.0-none</span><br><span class="line">$ newt pkg new apps/ibeacon-app -t app                                                                      2.4.2  8.1.3</span><br><span class="line">Download package template <span class="keyword">for</span> package <span class="built_in">type</span> app.</span><br><span class="line">Package successfuly installed into &lt;skip&gt;/mynewt-test/ibeacon-test/ibeacon/apps/ibeacon-app.</span><br><span class="line">$ newt target create ibeacon</span><br><span class="line">newt target create ble_tgt                                                                                2.4.2  8.1.3</span><br><span class="line">Target targets/ibeacon successfully created</span><br><span class="line">$ newt target <span class="built_in">set</span> ibeacon \</span><br><span class="line">  app=apps/ibeacon-app \</span><br><span class="line">  bsp=@apache-mynewt-core/hw/bsp/nrf51dk-16kbram \</span><br><span class="line">  build_profile=debug</span><br><span class="line">Target targets/ibeacon successfully <span class="built_in">set</span> target.app to apps/ibeacon-app</span><br><span class="line">Target targets/ibeacon successfully <span class="built_in">set</span> target.bsp to @apache-mynewt-core/hw/bsp/nrf51dk-16kbram</span><br><span class="line">Target targets/ibeacon successfully <span class="built_in">set</span> target.build_profile to debug</span><br></pre></td></tr></table></figure><p>Для поддержки BLE добавляем в&nbsp;pkg.yml нашего приложения пакеты, необходимые для работы BLE стэка</p><figure class="highlight yaml"><figcaption><span>pkg.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pkg.deps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;@apache-mynewt-core/kernel/os&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;@apache-mynewt-core/sys/console/full&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;@apache-mynewt-core/sys/log/full&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;@apache-mynewt-core/sys/stats/full&quot;</span></span><br><span class="line">    <span class="comment"># добавлены строки ниже</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;@apache-mynewt-core/net/nimble/controller&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;@apache-mynewt-core/net/nimble/host&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;@apache-mynewt-core/net/nimble/host/store/config&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;@apache-mynewt-core/net/nimble/transport/ram&quot;</span></span><br></pre></td></tr></table></figure><p>Ну и&nbsp;пробуем собрать нашу цель:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ newt build ibeacon</span><br></pre></td></tr></table></figure><h1 id="Грабля-первая"><a href="#Грабля-первая" class="headerlink" title="Грабля первая"></a>Грабля первая</h1><p>И вот тут-то нас ждёт засада</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ newt build ibeacon</span><br><span class="line">Building target targets/ibeacon</span><br><span class="line">...</span><br><span class="line">Linking /home/roman/.Projects/mynewt-test/ibeacon-test/ibeacon/bin/targets/ibeacon/app/apps/ibeacon-app/ibeacon-app.elf</span><br><span class="line">Error: /usr/lib/gcc/arm-none-eabi/7.3.0/../../../../arm-none-eabi/bin/ld: /home/roman/.Projects/mynewt-test/ibeacon-test/ibeacon/bin/targets/ibeacon/app/apps/ibeacon-app/ibeacon-app.elf section `.text<span class="string">&#x27; will not fit in region `FLASH&#x27;</span></span><br><span class="line">/usr/lib/gcc/arm-none-eabi/7.3.0/../../../../arm-none-eabi/bin/ld: region `FLASH<span class="string">&#x27; overflowed by 11224 bytes</span></span><br><span class="line"><span class="string">collect2: error: ld returned 1 exit status</span></span><br></pre></td></tr></table></figure><p>В общем собранный код не&nbsp;помещается в&nbsp;куцый объём 16Кбайт моего чипа. Есть вариант конечно выкинуть отладку и&nbsp;собрать optimized вариант, но&nbsp;вообще хотелось&nbsp;бы&nbsp;конечно и&nbsp;отладку сохранить. Очевидно нужно как-то уменьшить генерируемый объём кода.</p><p>В общем я&nbsp;нашёл 2&nbsp;варианта решения этой проблемы.</p><h2 id="Решение-первое-отключить-логгирование"><a href="#Решение-первое-отключить-логгирование" class="headerlink" title="Решение первое - отключить логгирование."></a>Решение первое&nbsp;&mdash; отключить логгирование.</h2><p>Для этого можно настроить уровень логгирования, что выполняется указанием в&nbsp;файле <code>syscfg.yml</code> приложения значения переменной <code>LOG_LEVEL</code> равным 255. Думаю 255&nbsp;уровней позволят подобрать оптимальный вариант, но&nbsp;мне уже просто хотелось поскорей запуститься, поэтому поставил 255, что означает выключение логов.</p><figure class="highlight yaml"><figcaption><span>syscfg.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="comment"># Settings this app overrides.</span></span><br><span class="line"><span class="attr">syscfg.vals:</span></span><br><span class="line">  <span class="attr">LOG_LEVEL:</span> <span class="number">255</span></span><br></pre></td></tr></table></figure><h2 id="Решение-второе-выключение-некоторых-пакетов"><a href="#Решение-второе-выключение-некоторых-пакетов" class="headerlink" title="Решение второе - выключение некоторых пакетов"></a>Решение второе&nbsp;&mdash; выключение некоторых пакетов</h2><p>По умолчанию при создании приложения у&nbsp;нас в&nbsp;pkg.yml добавляются следующие пакеты:</p><figure class="highlight yaml"><figcaption><span>pkg.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pkg.deps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;@apache-mynewt-core/sys/console/full&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;@apache-mynewt-core/sys/log/full&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;@apache-mynewt-core/sys/stats/full&quot;</span></span><br></pre></td></tr></table></figure><p>Чтобы уменьшить объем кода нужно заменить их&nbsp;на</p><figure class="highlight yaml"><figcaption><span>pkg.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pkg.deps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;@apache-mynewt-core/sys/console/minimal&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;@apache-mynewt-core/sys/log/stub&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;@apache-mynewt-core/sys/stats/stub&quot;</span></span><br></pre></td></tr></table></figure><p>После этих изменений сборка выполняется успешно.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ newt build ibeacon</span><br><span class="line">Building target targets/ibeacon</span><br><span class="line">...</span><br><span class="line">Target successfully built: targets/ibeacon</span><br></pre></td></tr></table></figure><h1 id="Грабля-номер-2-не-работает-UART-на-nrf51822"><a href="#Грабля-номер-2-не-работает-UART-на-nrf51822" class="headerlink" title="Грабля номер 2 - не работает UART на nrf51822"></a>Грабля номер 2&nbsp;&mdash; не&nbsp;работает UART на&nbsp;nrf51822</h1><p>Теперь, после того как сборка в&nbsp;общем-то заработала стоит добавить в&nbsp;проект какой-нибудь осмысленный&nbsp;код. Для этого внимательно читаем статью <a href="https://mynewt.apache.org/latest/os/tutorials/ibeacon/">BLE iBeacon</a>&nbsp;&mdash; там всё подробно разжёвано. Берём готовый код в&nbsp;конце статьи и&nbsp;записываем его в&nbsp;наш главный файл <code>src/main.c</code></p><figure class="highlight c"><figcaption><span>main.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysinit/sysinit.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;os/os.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;console/console.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;host/ble_hs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ble_app_set_addr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ble_addr_t</span> addr;</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">    rc = ble_hs_id_gen_rnd(<span class="number">1</span>, &amp;addr);</span><br><span class="line">    assert(rc == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    rc = ble_hs_id_set_rnd(addr.val);</span><br><span class="line">    assert(rc == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ble_app_advertise</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ble_gap_adv_params</span> <span class="title">adv_params</span>;</span></span><br><span class="line">    <span class="type">uint8_t</span> uuid128[<span class="number">16</span>];</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Arbitrarily set the UUID to a string of 0x11 bytes. */</span></span><br><span class="line">    <span class="built_in">memset</span>(uuid128, <span class="number">0x11</span>, <span class="keyword">sizeof</span> uuid128);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Major version=2; minor version=10. */</span></span><br><span class="line">    rc = ble_ibeacon_set_adv_data(uuid128, <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">    assert(rc == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Begin advertising. */</span></span><br><span class="line">    adv_params = (<span class="keyword">struct</span> ble_gap_adv_params)&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    rc = ble_gap_adv_start(BLE_OWN_ADDR_RANDOM, <span class="literal">NULL</span>, BLE_HS_FOREVER,</span><br><span class="line">                           &amp;adv_params, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    assert(rc == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ble_app_on_sync</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Generate a non-resolvable private address. */</span></span><br><span class="line">    ble_app_set_addr();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advertise indefinitely. */</span></span><br><span class="line">    ble_app_advertise();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    sysinit();</span><br><span class="line"></span><br><span class="line">    ble_hs_cfg.sync_cb = ble_app_on_sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* As the last thing, process events from default event queue. */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        os_eventq_run(os_eventq_dflt_get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Изначально я&nbsp;воспользовался первым методом для уменьшения размера кода. В&nbsp;результате после запуска кода на&nbsp;устройстве обнаружил периодическое мигание светодиода на&nbsp;выходе TX&nbsp;UART-а. Попытка просканировать эфир на&nbsp;наличие каких-либо iBeacon-ов ни&nbsp;к&nbsp;чему не&nbsp;привела. В&nbsp;общем ничего не&nbsp;заработало&nbsp;&mdash; только TX&nbsp;издевательски подмигивал&nbsp;мне, намекая, что стоит к&nbsp;нему подключиться и&nbsp;посмотреть что-же там такого.</p><p>В итоге подключил к&nbsp;UART-у переходник UART-&gt; USB и&nbsp;подцепившись терминалом к&nbsp;порту увидел, что за&nbsp;таинственные знаки подавал мне мигающий светодиод.</p><img src="/2018/02/15/mynewt-testing-ibeacon-example/nrf51822-uart-log.png" class="" title="Логи UART"><p>Видно, что периодически возникает assert и&nbsp;ошибка в&nbsp;обработке прерывания 2. Прерывание 2&nbsp;это UART. Т.е. видимо что-то не&nbsp;так с&nbsp;UART-ом.</p><p>Собственно именно это сподвигло меня заняться отладкой и&nbsp;обнаружить проблему в&nbsp;коде UART-а. То, что при этом уменьшился размер кода это лишь побочный эффект. Т.е. решением проблемы будет замена пакетов <code>log</code> и&nbsp;<code>stat</code> с&nbsp;full на&nbsp;stub.</p><p>Теперь после запуска приложения на&nbsp;устройстве можно увидеть beacon с&nbsp;мобильника</p><img src="/2018/02/15/mynewt-testing-ibeacon-example/beaconscanner.png" class="" title="Beacon Scanner видит устройство"><p>Так-же устройство видно из&nbsp;родной нордиковской программы nrfConnect.</p><img src="/2018/02/15/mynewt-testing-ibeacon-example/nordicsemi.android.mcp.png" class="" title="nRF Connect"><p>К сожалению нордиковское приложение <code>nRF Beacon</code> не&nbsp;смогло ничего обнаружить.</p><h1 id="Итоги"><a href="#Итоги" class="headerlink" title="Итоги"></a>Итоги</h1><p>В итоге получилось запустить рабочий код маяка на&nbsp;Mynewt, отловив при этом потенциальные проблемы. Далее в&nbsp;планах проверить работу датчиков совместно с&nbsp;модулем и&nbsp;отловить результаты на&nbsp;мобильнике.</p>]]></content>
    
    
    <summary type="html">Тестирую iBeacon пример для Mynewt OS</summary>
    
    
    
    <category term="uncategorized" scheme="https://diytronic.ru/categories/uncategorized/"/>
    
    
    <category term="nrf51822" scheme="https://diytronic.ru/tags/nrf51822/"/>
    
    <category term="mynewt" scheme="https://diytronic.ru/tags/mynewt/"/>
    
    <category term="nrf51" scheme="https://diytronic.ru/tags/nrf51/"/>
    
    <category term="ibeacon" scheme="https://diytronic.ru/tags/ibeacon/"/>
    
    <category term="nrf52" scheme="https://diytronic.ru/tags/nrf52/"/>
    
    <category term="nordic" scheme="https://diytronic.ru/tags/nordic/"/>
    
  </entry>
  
  <entry>
    <title>Исследую Mynewt OS</title>
    <link href="https://diytronic.ru/2018/02/06/exploring-mynewt-os/"/>
    <id>https://diytronic.ru/2018/02/06/exploring-mynewt-os/</id>
    <published>2018-02-06T19:26:03.000Z</published>
    <updated>2018-02-11T15:28:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>Давно хотел попробовать поиграться с&nbsp;какой-нибудь микроконтроллерной операционной системой. Наконец в&nbsp;контексте моего увлечения BLE модулями, где довольно много ресурсов, решил таки попробовать. В&nbsp;закладках уже давно болталась ссылка на&nbsp;<a href="http://mynewt.apache.org/">Mynewt</a> ну&nbsp;и&nbsp;наконец её&nbsp;время пришло. Итак пробую запустить на&nbsp;модуле nrf51822 <a href="http://mynewt.apache.org/">Mynewt</a>.</p><span id="more"></span><h1 id="ОС-на-микроконтроллере-что-за-бред"><a href="#ОС-на-микроконтроллере-что-за-бред" class="headerlink" title="ОС на микроконтроллере - что за бред?"></a>ОС на&nbsp;микроконтроллере&nbsp;&mdash; что за&nbsp;бред?</h1><p>Неоднократно слышал такое мнение в&nbsp;интернет, равно как и&nbsp;мнение, что писать надо только на&nbsp;ASM-е, и&nbsp;что С++ использовать нельзя и&nbsp;ещё много чего. В&nbsp;определённой степени оно верно, в&nbsp;особенности для маломощных контроллеров, для которых на&nbsp;счету каждый байт. В&nbsp;общем-то да&nbsp;&mdash; там это будет явный перебор. Но&nbsp;чорт побери&nbsp;&mdash; на&nbsp;дворе уже 2018&nbsp;год и&nbsp;контроллеры уже мощнее, чем мой первый компьютер. Лишние пара килобайт за&nbsp;удобство разработки и&nbsp;обслуживания давно уже не&nbsp;проблема, а&nbsp;накладные расходы практически незаметны. Поэтому вполне себе вариант.</p><h1 id="Почему-именно-Mynewt"><a href="#Почему-именно-Mynewt" class="headerlink" title="Почему именно Mynewt?"></a>Почему именно Mynewt?</h1><p>Самое главное&nbsp;&mdash; наличие BLE стэка и&nbsp;поддержка чипа nrf51822. Хотелось попробовать альтернативный и&nbsp;свободный BLE стэк.</p><h1 id="Установка"><a href="#Установка" class="headerlink" title="Установка"></a>Установка</h1><p>По счастью для ArchLinux есть готовый пакет, поэтому просто ставлю. Но&nbsp;для остальных случаев вроде как там много вариантов установки, включая Windows и&nbsp;MacOS.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yaourt -S mynewt-newt --noconfirm</span><br></pre></td></tr></table></figure><p>На самый край есть Docker образ</p><h1 id="Терминология"><a href="#Терминология" class="headerlink" title="Терминология"></a>Терминология</h1><p>Меня лично сходу немного сбила используемая терминология, поэтому остановлюсь на&nbsp;этом поподробнее.</p><h2 id="Проект"><a href="#Проект" class="headerlink" title="Проект"></a>Проект</h2><p>Итак у&nbsp;нас есть проект (project) &nbsp;&mdash; в&nbsp;общем проект это не&nbsp;набор настроек приложения как я&nbsp;ожидал, а&nbsp;некая папка где содержится набор приложений, настроек, зависимостей, библиотек (или в&nbsp;терминах Mynewt&nbsp;&mdash; пакетов (packages) ).</p><p>В общем-то это вполне логично. Вполне может быть проект, состоящий из&nbsp;нескольких железяк&nbsp;&mdash; типа датчики и&nbsp;контроллер для приёма и&nbsp;обработки с&nbsp;них данных. Соответственно в&nbsp;рамках одного проекта это разные устройства и&nbsp;вполне возможно на&nbsp;разных платформах.</p><p>Настройки проекта указываются в&nbsp;YAML файле <code>project.yml</code>.</p><h2 id="Пакет"><a href="#Пакет" class="headerlink" title="Пакет"></a>Пакет</h2><p>Пакет это основная фундаментальная единица проекта.</p><p>Пакетами (packages)  являются:</p><ul><li>приложения (applications) </li><li>библиотеки (libraries) </li><li>цели (targets) </li><li>возможно что-то ещё</li></ul><p>Каждый пакет это фактически папка с&nbsp;конфигурационным файлом <code>pkg.yml</code>, в&nbsp;котором указываются все настройки (описание, автор, тип и&nbsp;т.&nbsp;п.)  пакета, а&nbsp;так-же его зависимости&nbsp;&mdash; другие пакеты.</p><p>Тут тоже всё логично&nbsp;&mdash; дерево пакетов. По&nbsp;необходимости оно подтягивает все зависимости, что весьма удобно.</p><h2 id="BSP"><a href="#BSP" class="headerlink" title="BSP"></a>BSP</h2><p>Board Support Package&nbsp;&mdash; это пакет с&nbsp;набором настроек для конкретной железной платформы. Он&nbsp;содержит описание используемого микроконтроллера, соответствия пинов периферии и&nbsp;возможно что-то&nbsp;ещё. В&nbsp;общем случае при наличии правильного BSP нам не&nbsp;надо возиться с&nbsp;пинами, вместо этого мы&nbsp;будем пользоваться более высокоуровневыми объектами типа UART, SPI и&nbsp;т.&nbsp;п., а&nbsp;на&nbsp;какие пины это будет выведено за&nbsp;это уже отвечает&nbsp;BSP.</p><p>Соответственно, меняя BSP мы&nbsp;можем один и&nbsp;тот-же код быстро развернуть на&nbsp;другой платформе (если конечно там есть соответствующие ресурсы).</p><p>Mynewt уже &laquo;из коробки&raquo; имеет ряд сконфигурированных BSP для наиболее популярных плат и&nbsp;контроллеров.</p><h2 id="Цели"><a href="#Цели" class="headerlink" title="Цели"></a>Цели</h2><p>Цель (target)  это набор настроек для генерации кода под конкретную платформу. Каждая цель состоит&nbsp;из:</p><ul><li><p>приложения</p></li><li><p>BSP</p></li><li><p>типа сборки (build profile) &nbsp;&mdash; фактически это флаг <code>debug</code> или <code>optimized</code></p><p>Соответственно сборку, отладку и&nbsp;прошивку мы&nbsp;делаем именно для цели, а&nbsp;какое приложение и&nbsp;куда положить это уже у&nbsp;нас записано именно в&nbsp;ней.</p></li></ul><h1 id="Операционная-система"><a href="#Операционная-система" class="headerlink" title="Операционная система"></a>Операционная система</h1><p>Теперь немного о&nbsp;самой&nbsp;OS.&nbsp;Собственно как и&nbsp;любая операционная система Mynewt имеет ядро и&nbsp;приложения. Загружаться они могут 3-мя различными способами.</p><h2 id="Загрузка"><a href="#Загрузка" class="headerlink" title="Загрузка"></a>Загрузка</h2><p>Столкнулся с&nbsp;тем, что в&nbsp;примерах загрузка кода в&nbsp;устройство выполняется по&nbsp;разному&nbsp;&mdash; некоторые примеры просто заливают в&nbsp;устройство, а&nbsp;в&nbsp;некоторых предварительно заливается некоторый boot образ. Ну&nbsp;в&nbsp;команде прошивки указываются какие-то магические цифры 1 и&nbsp;0, назначение которых непонятно.</p><p>В какой-то момент эта магия надоела и&nbsp;полез разбираться. Описание нашёл, но&nbsp;уже в&nbsp;глубине документации. Как-то непонятно почему эти базовые концептуально важные вещи не&nbsp;расписать сразу и&nbsp;как можно раньше.</p><p>Оригинал описания процесса загрузки можно посмотреть <a href="http://mynewt.apache.org/os/modules/split/split/">тут</a></p><h3 id="Single"><a href="#Single" class="headerlink" title="Single"></a>Single</h3><p>Весь код заливается одним большим куском, загружаемым по&nbsp;адресу 0. Железо стартует прямо с&nbsp;кода приложения. Недостатком этого способа является невозможность обновления кода без полной перепрошивки.</p><h3 id="Unified"><a href="#Unified" class="headerlink" title="Unified"></a>Unified</h3><p>В этом случае у&nbsp;нас есть бутлодер, который размещается по&nbsp;нулевому адресу. Соответственно управление при старте передаётся&nbsp;ему, а&nbsp;он&nbsp;в&nbsp;свою очередь организует загрузку нужного образа системы и&nbsp;передаёт ему управление. Образы системы хранятся в&nbsp;так называемых слотах. Есть 2&nbsp;слота для загрузки образов&nbsp;&mdash; 0 и&nbsp;1.</p><p>Очевидным достоинством способа является возможность обновлять код приложения &laquo;на лету&raquo;, не&nbsp;используя специальных устройств для прошивки, например заливкой образа через UART.</p><h3 id="Split"><a href="#Split" class="headerlink" title="Split"></a>Split</h3><p>Этот способ отличается от&nbsp;предыдущих&nbsp;тем, что код разделён между 2-мя образами&nbsp;&mdash; загрузчиком и&nbsp;приложением, которые заливаютс соответственно в&nbsp;слоты 0 и&nbsp;1.</p><p>Загрузчик содержит непосредственно ядро Mynewt, сетевой стэк, возможно что-то&nbsp;ещё, необходимое для загрузки образа. По&nbsp;сути он&nbsp;выполняет те-же функции, что и&nbsp;бутлодер из&nbsp;Unified варианта загрузки, но&nbsp;дополнительно содержит сервер обновления, которые позволяет выполнить обновление кода по&nbsp;сети (включая BLE).</p><p>Приложение содержит части Mynewt которые не&nbsp;нужны на&nbsp;этапе загрузки и&nbsp;код непосредственно самого приложения.</p><p>Этот способ чем-то похож на&nbsp;SoftDevice, используемый в&nbsp;nRF&nbsp;SDK.</p><h1 id="Создаём-проект"><a href="#Создаём-проект" class="headerlink" title="Создаём проект"></a>Создаём проект</h1><p>Изначально я&nbsp;хотел потестировать BLE стэк, но&nbsp;по&nbsp;неопытности и&nbsp;по&nbsp;не&nbsp;знанию базовых концепций Mynewt немного начудил с&nbsp;конфигурацией и&nbsp;не&nbsp;смог прошить устройство, поэтому откатился на&nbsp;более простой вариант&nbsp;&mdash; мигание светодиодом. Поэтому в&nbsp;примерах в&nbsp;названии проекта будет присутствовать слово <code>ble</code>.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ newt new test_project</span><br><span class="line">Downloading project skeleton from apache/mynewt-blinky...</span><br><span class="line">Installing skeleton <span class="keyword">in</span> test_project...</span><br><span class="line">Project test_project successfully created.</span><br></pre></td></tr></table></figure><p>Теперь надо скачать зависимости проекта. Для этого переходим в&nbsp;папку только что созданного проекта и&nbsp;запускаем нужную команду <code>newt install</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> test_project</span><br><span class="line">$ newt install</span><br><span class="line">apache-mynewt-core successfully installed version 1.3.0-none</span><br></pre></td></tr></table></figure><p>Выполняется довольно долго&nbsp;&mdash; видимо выкачивает что-то, но&nbsp;никаких при этом визуальных эффектов. Нехорошо.</p><p>Теперь нужно создать приложение, но&nbsp;как оказалось новый проект автоматически создаёт приложение для мигания светодиодом (apps/blinky), поэтому шаг создания приложения пропущу.</p><p>Теперь нам надо создать цели (target)  для бутлодера и&nbsp;для приложения. Для nrf51822&nbsp;есть 2&nbsp;BSP&nbsp;&mdash; для моего <code>AC</code> чипа c&nbsp;16Кбайт памяти нашёл отдельный специальный&nbsp;BSP, что несомненно порадовало.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ newt target create nrf51_boot                                                                        2.4.2  8.1.3</span><br><span class="line">Target targets/nrf51_boot successfully created</span><br><span class="line"></span><br><span class="line">$ newt target <span class="built_in">set</span> nrf51_boot app=@apache-mynewt-core/apps/boot bsp=@apache-mynewt-core/hw/bsp/nrf51dk-16kbram build_profile=optimized</span><br><span class="line">Target targets/nrf51_boot successfully <span class="built_in">set</span> target.app to @apache-mynewt-core/apps/boot</span><br><span class="line">Target targets/nrf51_boot successfully <span class="built_in">set</span> target.bsp to @apache-mynewt-core/hw/bsp/nrf51dk-16kbram</span><br><span class="line">Target targets/nrf51_boot successfully <span class="built_in">set</span> target.build_profile to optimized</span><br><span class="line"></span><br><span class="line">$ newt target create blinky                                                                            2.4.2  8.1.3</span><br><span class="line">Target targets/blinky successfully created</span><br><span class="line"></span><br><span class="line">$ newt target <span class="built_in">set</span> blinky app=apps/blinky bsp=@apache-mynewt-core/hw/bsp/nrf51dk-16kbram build_profile=debug</span><br><span class="line">Target targets/blinky successfully <span class="built_in">set</span> target.app to apps/blinky</span><br><span class="line">Target targets/blinky successfully <span class="built_in">set</span> target.bsp to @apache-mynewt-core/hw/bsp/nrf51dk-16kbram</span><br><span class="line">Target targets/blinky successfully <span class="built_in">set</span> target.build_profile to debug</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>И запускаем сборку</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ newt build blinky</span><br><span class="line">...</span><br><span class="line">Target successfully built: targets/blinky</span><br><span class="line"></span><br><span class="line">$ newt build nrf51_boot</span><br><span class="line">Building target targets/nrf51_boot</span><br><span class="line">...</span><br><span class="line">Target successfully built: targets/nrf51_boot</span><br></pre></td></tr></table></figure><p>Заливаем бутлодер в&nbsp;устройство, предварительно подключив программатор (SEGGER JLink)  к&nbsp;плате.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ newt load nrf51_boot</span><br><span class="line">Loading bootloader</span><br></pre></td></tr></table></figure><p>Пробую запустить приложение&nbsp;&mdash; не&nbsp;забываем указать слот 1 &hellip; хотя попробовал залить в&nbsp;нулевой слот и&nbsp;оно тоже заработало.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ newt run blinky 1</span><br></pre></td></tr></table></figure><p>В результате видим окно дебаггера&nbsp;&mdash; вводим команду <code>c</code> и&nbsp;плата начинает активно мигать светодиодом.</p><img src="/2018/02/06/exploring-mynewt-os/segger-mynewt-debugging.png" class="" title="Запуск примера с мигающим светодиодом"><h1 id="Итоги"><a href="#Итоги" class="headerlink" title="Итоги"></a>Итоги</h1><p>В итоге всё получилось&nbsp;&mdash; код собирается, заливается в&nbsp;устройство и&nbsp;работает. Следующим шагом будет безусловно запуск BLE стэка, что лично для меня представляет наибольший интерес. Ну&nbsp;и&nbsp;можно будет уже поиграться с&nbsp;кодом&nbsp;т.&nbsp;к.&nbsp;в&nbsp;этом проекте в&nbsp;код можно даже не&nbsp;заглядывать (хотя я&nbsp;конечно уже посмотрел).</p><h1 id="Источник"><a href="#Источник" class="headerlink" title="Источник"></a>Источник</h1><ul><li><a href="https://learn.adafruit.com/adafruit-nrf52-pro-feather/apache-mynewt-applications">https://learn.adafruit.com/adafruit-nrf52-pro-feather/apache-mynewt-applications</a></li><li><a href="https://electronix.ru/forum/lofiversion/index.php/t144345.html">https://electronix.ru/forum/lofiversion/index.php/t144345.html</a></li><li><a href="http://mynewt.apache.org/os/tutorials/ibeacon/">http://mynewt.apache.org/os/tutorials/ibeacon/</a></li></ul>]]></content>
    
    
    <summary type="html">Что такое Mynewt и как с ней работать. Запускаем моргалку светодиодом на Mynewt OS.</summary>
    
    
    
    <category term="uncategorized" scheme="https://diytronic.ru/categories/uncategorized/"/>
    
    
    <category term="mcu" scheme="https://diytronic.ru/tags/mcu/"/>
    
    <category term="nrf51822" scheme="https://diytronic.ru/tags/nrf51822/"/>
    
    <category term="mynewt" scheme="https://diytronic.ru/tags/mynewt/"/>
    
  </entry>
  
  <entry>
    <title>Открыл для себя PlatformIO</title>
    <link href="https://diytronic.ru/2018/01/29/welcome-to-platformio-great-tool-for-setup-boards-software/"/>
    <id>https://diytronic.ru/2018/01/29/welcome-to-platformio-great-tool-for-setup-boards-software/</id>
    <published>2018-01-29T16:00:23.000Z</published>
    <updated>2018-01-30T08:39:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>На днях много времени потратил на&nbsp;доводку и&nbsp;калибровку 3d принтера. В&nbsp;связи с&nbsp;этим пришлось довольно часто обновлять прошивку принтера. Ну&nbsp;и&nbsp;т.&nbsp;к.&nbsp;в&nbsp;принтере используется плата, совместимая с&nbsp;Arduino, то&nbsp;пользовался я&nbsp;для этого Arduino&nbsp;IDE, что очень неудобно, т.&nbsp;к.&nbsp;постоянно приходилось менять порт подключения. В&nbsp;итоге начал искать как зафиксировать порт в&nbsp;Arduino. Но&nbsp;в&nbsp;итоге я&nbsp;нашёл нечто более удобное, а&nbsp;именно <a href="http://platformio.org/">PlatformIO</a> и&nbsp;как раз впечатлением об&nbsp;этой штуке я&nbsp;и&nbsp;хочу поделиться.</p><span id="more"></span><h1 id="Зачем-оно"><a href="#Зачем-оно" class="headerlink" title="Зачем оно?"></a>Зачем&nbsp;оно?</h1><p>В общем как я&nbsp;понял это некий репозитарий библиотек, фреймворков и&nbsp;конфигураций для различных типовых отладочных плат. Судя по&nbsp;описанию поддерживается более <a href="http://platformio.org/boards?filter%5Bframeworks%5D=mbed">200&nbsp;отладочных плат</a> и&nbsp;около <a href="http://platformio.org/frameworks/mbed">10&nbsp;библиотек</a> (включая кстати поддержку BLE чипов от&nbsp;Nordic, что лично меня очень радует) </p><p>В общем суть проекта такова&nbsp;&mdash; выбираем плату, выбираем фреймворк и&nbsp;всё&nbsp;&mdash; остальное оно делает за&nbsp;нас&nbsp;&mdash; выкачивает все библиотеки и&nbsp;зависимости, настраивает конфигурацию для разработки кода и&nbsp;заливки его в&nbsp;плату. В&nbsp;общем это просто чудовищное облегчение и&nbsp;избавление от&nbsp;рутины.</p><h1 id="Что-не-так-с-Arduino-IDE"><a href="#Что-не-так-с-Arduino-IDE" class="headerlink" title="Что не так с Arduino IDE"></a>Что не&nbsp;так с&nbsp;Arduino IDE</h1><p>Не может само найти правильный порт. При переподключении устройства и&nbsp;смене нумерации порта начинаются проблемы. Порт меняется в&nbsp;меню (с какой-то задержкой), но&nbsp;при этом он&nbsp;не&nbsp;выбран. В&nbsp;итоге надо постоянно лазить в&nbsp;меню с&nbsp;выбором порта, ждать пока оно обновиться и&nbsp;снова прокликивать, чтоб подключилось. Бесит жутко. Ладно если это нужно не&nbsp;часто, но&nbsp;когда идёт отладка на&nbsp;это уже невозможно не&nbsp;обращать внимание.</p><p>Не понимает, что файл изменился во&nbsp;внешнем редакторе. Бывает, что файл прям под рукой и&nbsp;проще открыть и&nbsp;поправить текстовым редактором прям из&nbsp;консоли, чем лезть в&nbsp;IDE и&nbsp;снова искать этот файл и&nbsp;нужную строку кода. Но&nbsp;после этого в&nbsp;IDE файл не&nbsp;меняется, т.&nbsp;е.&nbsp;IDE не&nbsp;следит за&nbsp;содержимым файла. Соответственно все изменения легко потерять.</p><p>Нет интеграции с&nbsp;системами контроля версий. На&nbsp;дворе если что 2018&nbsp;год.</p><p>Убогий GUI под Linux. Это конечно проблема Java на&nbsp;Linux-е, но&nbsp;тем не&nbsp;менее. Лучше уж&nbsp;никак чем смотреть на&nbsp;эти корявые менюхи и&nbsp;шрифты без нормального сглаживания.</p><h1 id="Установка"><a href="#Установка" class="headerlink" title="Установка"></a>Установка</h1><p>Сначала установил из&nbsp;пакетов, но&nbsp;при попытке обновиться командой <code>platformio upgrade</code> получил кучу ошибок на&nbsp;тему, что надо удалить пакет, чего-то там конфликтует и&nbsp;прочие ошибки, поэтому решил ставить родными средствами питона.</p><p>Питон тоже слегка заартачился&nbsp;&mdash; в&nbsp;общем 3-я версия питона не&nbsp;катит&nbsp;&mdash; ставить нужно на&nbsp;вторую. Но&nbsp;у&nbsp;меня оно есть, поэтому особых проблем не&nbsp;испытал.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip2 install -U platformio</span><br></pre></td></tr></table></figure><p>После этого апгрейд радостно сообщил&nbsp;мне, что у&nbsp;меня последняя версия.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ platformio upgrade</span><br><span class="line">You<span class="string">&#x27;re up-to-date!</span></span><br><span class="line"><span class="string">PlatformIO 3.5.1 is currently the newest version available.</span></span><br></pre></td></tr></table></figure><h1 id="Конфигурация-для-Marlin-а"><a href="#Конфигурация-для-Marlin-а" class="headerlink" title="Конфигурация для Marlin-а"></a>Конфигурация для Marlin-а</h1><p>О чудо! В&nbsp;корне папки с&nbsp;Marlin-ом обнаружил заветный файлик <code>platformio.ini</code>. А&nbsp;это означает ничто иное как&nbsp;то, что Marlin уже имеет поддержку PlatformIO и&nbsp;конфигурировать ничего не&nbsp;надо. Да&nbsp;и&nbsp;в&nbsp;конфиге по&nbsp;умолчанию уже стоит именно ардуина от&nbsp;моего принтера.</p><p>Пробую обновить ардуинские библиотеки.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ platformio update</span><br><span class="line">Please <span class="built_in">wait</span> <span class="keyword">while</span> upgrading PlatformIO...</span><br><span class="line">Platform Atmel AVR</span><br><span class="line">--------</span><br><span class="line">Updating atmelavr                        @ 1.8.1          [Up-to-date]</span><br><span class="line">Updating toolchain-atmelavr              @ 1.40902.0      [Up-to-date]</span><br><span class="line">Updating framework-arduinoavr            @ 1.10620.2      [Up-to-date]</span><br><span class="line"></span><br><span class="line">PlatformIO has been successfully upgraded to 3.5.1!</span><br></pre></td></tr></table></figure><p>Ну и&nbsp;запускаю сборку</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ platformio run</span><br><span class="line">Warning! Ignore unknown `envs_dir` option <span class="keyword">in</span> `[platformio]` section</span><br><span class="line">[Mon Jan 29 19:08:39 2018] Processing megaatmega2560 (build_flags: -I <span class="variable">$BUILDSRC_DIR</span> -fmax-errors=5; lib_deps: U8glib@1.19.1, TMC2130Stepper, Adafruit NeoPixel, https://github.com/lincomatic/LiquidTWI2.git, https://github.com/trinamic/TMC26XStepper.git; board_f_cpu: 16000000L; platform: atmelavr; board: megaatmega2560; framework: arduino)</span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">Verbose mode can be enabled via `-v, --verbose` option</span><br><span class="line">Converting Marlin.ino</span><br><span class="line">Collected 29 compatible libraries</span><br><span class="line">Scanning dependencies...</span><br><span class="line">Library Dependency Graph ( http://bit.ly/configure-pio-ldf )</span><br><span class="line">|-- &lt;U8glib&gt; v1.19.1</span><br><span class="line">|-- &lt;TMC2130Stepper&gt; v2.1.3</span><br><span class="line">|   |-- &lt;SPI&gt; v1.0</span><br><span class="line">|-- &lt;Adafruit NeoPixel&gt; v1.1.5</span><br><span class="line">|-- &lt;LiquidTWI2&gt; <span class="comment">#30aa480</span></span><br><span class="line">|   |-- &lt;Wire&gt; v1.0</span><br><span class="line">|-- &lt;TMC26XStepper&gt; <span class="comment">#c1921b4</span></span><br><span class="line">|   |-- &lt;SPI&gt; v1.0</span><br><span class="line">|-- &lt;SoftwareSerial&gt; v1.0</span><br><span class="line">|-- &lt;LiquidCrystal&gt; v1.0.5</span><br><span class="line">|-- &lt;SPI&gt; v1.0</span><br><span class="line">|-- &lt;Wire&gt; v1.0</span><br><span class="line">Compiling .pioenvs/megaatmega2560/src/G26_Mesh_Validation_Tool.o</span><br><span class="line">Compiling .pioenvs/megaatmega2560/src/I2CPositionEncoder.o</span><br><span class="line">Compiling .pioenvs/megaatmega2560/src/M100_Free_Mem_Chk.o</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">======= [SUCCESS] Took 12.14 seconds ===========</span><br></pre></td></tr></table></figure><p>Просто идеально! Всосало все какие нужно зависимости и&nbsp;собрало проект под моё железо.</p><h1 id="Заливаю-прошивку"><a href="#Заливаю-прошивку" class="headerlink" title="Заливаю прошивку"></a>Заливаю прошивку</h1><p>Для заливки прошивки в&nbsp;платформу по&nbsp;умолчанию используем команду</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ platformio run -t upload</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Looking <span class="keyword">for</span> upload port...</span><br><span class="line">Auto-detected: /dev/ttyUSB2</span><br><span class="line">Uploading .pioenvs/megaatmega2560/firmware.hex</span><br><span class="line"></span><br><span class="line">avrdude: AVR device initialized and ready to accept instructions</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>При этом оно само выкачало <code>avrdude</code>, определило нужный порт и&nbsp;залило прошивку. Сказать, что я&nbsp;удивлён это ничего не&nbsp;сказать. Больше не&nbsp;нужен этот геморрой с&nbsp;переключением портов.</p><h1 id="Источники"><a href="#Источники" class="headerlink" title="Источники"></a>Источники</h1><p>В общем-то уже после того как это написал нашёл <a href="https://geektimes.ru/post/273852/">статью на&nbsp;Geektimes о&nbsp;PlatformIO</a>. А&nbsp;так в&nbsp;общем и&nbsp;целом в&nbsp;рунете какой-то информации о&nbsp;PlatformIO не&nbsp;сказать, что много.</p><h1 id="Итого"><a href="#Итого" class="headerlink" title="Итого"></a>Итого</h1><p>У меня конечно ещё вау-эффект не&nbsp;закончился, но&nbsp;тем не&nbsp;менее хочу сказать, что это просто находка. Рекомендую всем хотя&nbsp;бы&nbsp;попробовать. Лично для меня это удобно&nbsp;тем, что я&nbsp;могу избавиться от&nbsp;использования Arduino IDE (собственно и&nbsp;раньше ничего не&nbsp;мешало, но&nbsp;городить кучу скриптов не&nbsp;было желания)  и&nbsp;переключиться на&nbsp;обычный редактор, а&nbsp;код безболезненно собирать PlatformIO.</p><p>Планирую попробовать заменить этой штукой makefile-ы в&nbsp;других проектах. Думаю должно получиться.</p><p>Ну и&nbsp;уже руки чешутся попробовать использовать PlatformIO для разработки кода под nRF чипы, что вроде как PlatformIO позволяет.</p>]]></content>
    
    
    <summary type="html">Краткое описание и впечатления об использовании платформы PlatformIO для обновления прошивки 3d принтера.</summary>
    
    
    
    <category term="electronics" scheme="https://diytronic.ru/categories/electronics/"/>
    
    
    <category term="arduino" scheme="https://diytronic.ru/tags/arduino/"/>
    
    <category term="marlin" scheme="https://diytronic.ru/tags/marlin/"/>
    
    <category term="platform-io" scheme="https://diytronic.ru/tags/platform-io/"/>
    
  </entry>
  
  <entry>
    <title>Обновил Marlin до 1.1.8. Снова грабли.</title>
    <link href="https://diytronic.ru/2018/01/28/sunhokey-prusa-i4-marlin-update-to-1-1-8/"/>
    <id>https://diytronic.ru/2018/01/28/sunhokey-prusa-i4-marlin-update-to-1-1-8/</id>
    <published>2018-01-28T14:53:31.000Z</published>
    <updated>2018-04-25T22:35:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>На днях тут починил наконец грелку в&nbsp;принтере и&nbsp;чорт меня дёрнул до&nbsp;кучи обновить ещё и&nbsp;прошивку. Думаю ну&nbsp;пока уж&nbsp;занялся ремонтом то&nbsp;уж&nbsp;заодно и&nbsp;обновлюсь&nbsp;&mdash; дело-то нехитрое. Но&nbsp;не&nbsp;тут-то было&nbsp;&mdash; в&nbsp;итоге пришлось изрядно попотеть.</p><span id="more"></span><p>Итак&nbsp;&mdash; для начала мелочь&nbsp;&mdash; новый марлин категорически отказался компилироваться выдавая страшные надпись о&nbsp;нехватке какого-то файла LiquidCrystal.h Исправил этот косячок простой установкой в&nbsp;Arduino IDE одноимённой библиотеки стандартными средствами самой&nbsp;IDE. После этого проект успешно собрался и&nbsp;я&nbsp;не&nbsp;чуя подвоха смело залил прошивку в&nbsp;принтер.</p><p>Однако, наученный горьким опытом первым делом решил проверить работу осей&nbsp;Z.&nbsp;После того как принтер как-то раз чуть не&nbsp;выломал их&nbsp;после неудачной прошивки я&nbsp;в&nbsp;этом вопросе очень щепетилен. Дело в&nbsp;том, что у&nbsp;принтеров типа Prusa имеется 2-е независимых оси&nbsp;Z, которые работают от&nbsp;независимых двигателей, что требует дополнительных усилий по&nbsp;их&nbsp;синхронизации. В&nbsp;прошивке за&nbsp;это дело отвечает переменная:</p><pre class="code language language-arduino"><code class="language language-arduino"><span class="token macro property">#<span class="token directive keyword">define</span> Z_DUAL_STEPPER_DRIVERS</span></code></pre><p>В общем вот этот define должен быть раскомментирован. Это важно! Иначе один двигатель работать не&nbsp;будет и&nbsp;если вы&nbsp;будете недостаточно проворными, чтобы вовремя остановить это безобразие то&nbsp;есть риск повредить конструкцию принтера.</p><p>Итак после обновления прошивки и&nbsp;включения принтера первым делом пробую вручную легонько подвигать осями Z&nbsp;из&nbsp;меню принтера. Но&nbsp;в&nbsp;этот раз с&nbsp;к&nbsp;своему удивлению обнаружил, что опять вращается только один двигатель. После многократных проверок и&nbsp;перепроверок я&nbsp;обнаружил, что крутятся оба двигателя, но&nbsp;почему-то с&nbsp;разной скоростью.</p><p>В итоге обнаружил аналогичную проблему у&nbsp;других пользователей Marlin-а. Вот <a href="https://github.com/MarlinFirmware/Marlin/issues/6456">обсуждение проблемы несинхронного вращения двигателей оси Z</a>. По&nbsp;счастью решение нашлось. В&nbsp;общем многие, как впрочем и&nbsp;я, обновляли марлин пользуясь в&nbsp;качестве образца патченным китайцами марлином, заточенным под конкретный принтер. И&nbsp;в&nbsp;итоге многие настройки перекочевали &laquo;как есть&raquo;. Как говорится в&nbsp;старой сисадминской поговорке&nbsp;&mdash; &laquo;работает&nbsp;&mdash; не&nbsp;тронь&raquo;&nbsp;&mdash; вот оно и&nbsp;работало до&nbsp;поры до&nbsp;времени.</p><p>У китайцев почему-то (я сам удивлялся)  значение переменной <code>POWER_SUPPLY</code> было выставлено в&nbsp;единицу, что в&nbsp;общем-то означает, что у&nbsp;нас ATX блок питания, что в&nbsp;свою очередь означает, что один из&nbsp;пинов предназначен для включения этого блока.</p><pre class="code language language-arduino"><code class="language language-arduino"><span class="token comment">/** * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN * * 0 = No Power Switch * 1 = ATX * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC) * * :{ 0:'No power switch', 1:'ATX', 2:'X-Box 360' } */</span><span class="token macro property">#<span class="token directive keyword">define</span> POWER_SUPPLY 0</span></code></pre><p>В итоге в&nbsp;новой версии у&nbsp;марлина с&nbsp;этим вышел конфликт и&nbsp;на&nbsp;включения блока питания переназначился один из&nbsp;пинов, ответственный за&nbsp;управления двигателем. В&nbsp;общем эту переменную нужно выключить, установив нулевое значение, что впрочем вполне логично.</p><p>Ну и&nbsp;вторым моментом является смена типа материнской платы с&nbsp;<code>BOARD_MKS_13</code> на&nbsp;<code>BOARD_MKS_BASE</code>, т.&nbsp;к.&nbsp;там тоже какие-то коллизии с&nbsp;пинами.</p><pre class="code language language-arduino"><code class="language language-arduino"><span class="token comment">// The following define selects which electronics board you have.</span><span class="token comment">// Please choose the name from boards.h that matches your setup</span><span class="token macro property">#<span class="token directive keyword">ifndef</span> MOTHERBOARD</span>  <span class="token macro property">#<span class="token directive keyword">define</span> MOTHERBOARD BOARD_MKS_BASE</span><span class="token macro property">#<span class="token directive keyword">endif</span></span></code></pre><p>Я проверил&nbsp;&mdash; нужно исправлять именно обе переменные&nbsp;&mdash; по&nbsp;одной не&nbsp;срабатывает.</p><h1 id="Итог"><a href="#Итог" class="headerlink" title="Итог"></a>Итог</h1><p>Обновил код на&nbsp;github&nbsp;&mdash; <a href="https://github.com/webhive/sunhokey-prusa-i4">https://github.com/webhive/sunhokey-prusa-i4</a>. Теперь там корректные файлы для версии 1.1.8</p>]]></content>
    
    
    <summary type="html">Проблемы и их решения при обновлении прошивки 3d принтера Sunhokey Prusa I4 до версии marlin-1.1.8</summary>
    
    
    
    <category term="3d-print" scheme="https://diytronic.ru/categories/3d-print/"/>
    
    
    <category term="marlin" scheme="https://diytronic.ru/tags/marlin/"/>
    
    <category term="sunhokey-prusa-i4" scheme="https://diytronic.ru/tags/sunhokey-prusa-i4/"/>
    
  </entry>
  
  <entry>
    <title>Калибровка термодатчика кровати</title>
    <link href="https://diytronic.ru/2018/01/27/heat-bed-thermistor-calibration/"/>
    <id>https://diytronic.ru/2018/01/27/heat-bed-thermistor-calibration/</id>
    <published>2018-01-27T10:37:50.000Z</published>
    <updated>2018-01-28T14:21:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>Не так давно у&nbsp;меня случилась беда&nbsp;&mdash; сгорел силиконовый нагреватель стола 3d принтера от&nbsp;фирмы Keenovo. Вернее не&nbsp;то&nbsp;чтобы совсем сгорел&nbsp;&mdash; грел исправно, но&nbsp;при этом жутко вонял и&nbsp;внутри образовалась обгоревшая область. В&nbsp;общем в&nbsp;итоге я&nbsp;не&nbsp;стал искушать судьбу и&nbsp;заменил его на&nbsp;другой, но&nbsp;уже китайский noname. Сегодня занимался калибровкой ну&nbsp;и&nbsp;решил выложить результаты.</p><span id="more"></span><p>В общем <a href="http://ali.pub/2835i0">новая силиконовая грелка</a>)  если кому интересно продаётся <a href="http://ali.pub/2835i0">тут</a>. По&nbsp;характеристикам она идентична старой грелку от&nbsp;Keenovo, но&nbsp;качество заметно хуже в&nbsp;связи с&nbsp;чем я&nbsp;конечно ожидал всяческих неожиданностей и&nbsp;после установки решил провести калибровку.</p><p>Заявлено, что грелка оснащена терморезистором NTC 100К 3950.</p><p>Алгоритм калибровки я&nbsp;тут приводить не&nbsp;буду&nbsp;&mdash; про него уже написано достаточно. Например вот в&nbsp;этой <a href="http://3dtoday.ru/blogs/3diy/the-thermistor-setting-in-the-firmware/">статье на&nbsp;3D today</a>. В&nbsp;общем сидел час с&nbsp;лишним ступеньками повышая температуру через Repetier-Host, брал из&nbsp;него значения&nbsp;АЦП, потом измерял температуру поверхности китайским пирометром и&nbsp;заносил всё в&nbsp;таблицу.</p><img src="/2018/01/27/heat-bed-thermistor-calibration/bed-calibration-1.png" class="" title="Калибровка в Repetier-Host"><p>Заметна кстати, что PID не&nbsp;очень хорошо настроен&nbsp;&mdash; значения слегка &laquo;вылетают&raquo; за&nbsp;ступеньку.</p><p>В итоге после всех замеров получил вот такой график:</p><img src="/2018/01/27/heat-bed-thermistor-calibration/bed-calibration-2.png" class="" title="Результаты калибровки"><p>Максимальное расхождение температуры на&nbsp;стекле и&nbsp;на&nbsp;термодатчике&nbsp;&mdash; 26&nbsp;градусов. Многовато конечно, но&nbsp;боле-менее. У&nbsp;старой грелки Keenovo максимальная разница была 15&nbsp;градусов, но&nbsp;она была приклеена на&nbsp;свой термоскотч, а&nbsp;новую я&nbsp;приклеил на&nbsp;высокотемпературный герметик. Видимо он&nbsp;таки оказывает некоторое термосопротивление, хотя может и&nbsp;сама грелка не&nbsp;такая качественная.</p><p>Аналогичную процедуру я&nbsp;в&nbsp;своё время проделывал с&nbsp;оригинальной грелкой от&nbsp;Keenovo, поэтому появилась возможность сравнить результаты.</p><img src="/2018/01/27/heat-bed-thermistor-calibration/keenovo-vs-noname.png" class="" title="Kennovo vs Noname сравнение"><p>Довольно неожиданно результаты оказались практически идентичными&nbsp;&mdash; максимальное расходжение (ближе к&nbsp;высоким значениям температуры)  получились около 8&nbsp;процентов. Хотя с&nbsp;другой стороны почему неожиданно? Идентичный терморезистор даёт идентичные значения. Видимо из-за невысокого качества грелки ожидал худшего.</p><p>В общем итого&nbsp;&mdash; грелку можно брать&nbsp;&mdash; хоть и&nbsp;тонкие провода и&nbsp;чорт его знает кто производитель, но&nbsp;исправно греет и&nbsp;выдаёт вполне адекватные значения температуры.</p><h1 id="Источники"><a href="#Источники" class="headerlink" title="Источники"></a>Источники</h1><ul><li><a href="http://3dtoday.ru/blogs/3diy/the-thermistor-setting-in-the-firmware/">http://3dtoday.ru/blogs/3diy/the-thermistor-setting-in-the-firmware/</a></li><li><a href="https://nutz95.wordpress.com/2014/04/13/marlin-firmware-thermistor-3950-table/">https://nutz95.wordpress.com/13.04.2014/marlin-firmware-thermistor-3950-table/</a></li><li><a href="http://3dtoday.ru/questions/the-chinese-ntc-3950-thermistor-the-values-of-adc-to-be-added-to-the-m/">http://3dtoday.ru/questions/the-chinese-ntc-3950-thermistor-the-values-of-adc-to-be-added-to-the-m/</a></li><li><a href="https://3deshnik.ru/blogs/akdzg/nastrojka-proshivki-marlin-dlya-3d-printera">https://3deshnik.ru/blogs/akdzg/nastrojka-proshivki-marlin-dlya-3d-printera</a></li><li><a href="http://reprap.org/wiki/PID_Tuning">http://reprap.org/wiki/PID_Tuning</a></li></ul>]]></content>
    
    
    <summary type="html">Результаты калибровки термодатчика китайского силиконового нагревателя стола 3d принтера.</summary>
    
    
    
    <category term="3d-print" scheme="https://diytronic.ru/categories/3d-print/"/>
    
    
    <category term="heatbed" scheme="https://diytronic.ru/tags/heatbed/"/>
    
    <category term="sunhokey-prusa-i4" scheme="https://diytronic.ru/tags/sunhokey-prusa-i4/"/>
    
    <category term="keenovo" scheme="https://diytronic.ru/tags/keenovo/"/>
    
    <category term="silicone-heater" scheme="https://diytronic.ru/tags/silicone-heater/"/>
    
  </entry>
  
  <entry>
    <title>Снова nRF51822 - пробуем запустить Bluetooth</title>
    <link href="https://diytronic.ru/2018/01/08/nrf51822-trying-to-make-bluetooth-working/"/>
    <id>https://diytronic.ru/2018/01/08/nrf51822-trying-to-make-bluetooth-working/</id>
    <published>2018-01-08T09:40:11.000Z</published>
    <updated>2018-01-09T22:12:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>В <a href="/2017/12/05/testing-nrf51822-ble-module/" title="первой статье, посвящённой nRF51822 модулю">первой статье, посвящённой nRF51822&nbsp;модулю</a> и&nbsp;опытов над ним я&nbsp;запустил на&nbsp;этом модуле простейшую мигалку светодиодами. Но&nbsp;это вовсе не&nbsp;то&nbsp;для чего создавался этот модуль и&nbsp;главная цель это получение полноценного BLE устройства. Поэтому продолжаю эксперименты и&nbsp;попробую поднять на&nbsp;устройстве&nbsp;BLE.</p><span id="more"></span><p>Для начала было&nbsp;бы&nbsp;неплохо узнать, что у&nbsp;нас есть на&nbsp;борту. Зачем это нужно станет понятно в&nbsp;дальнейшем, а&nbsp;пока поверьте мне на&nbsp;слово&nbsp;&mdash; это важно. Поэтому в&nbsp;начале небольшое лирическое отступление и&nbsp;минутка теории.</p><h1 id="Как-узнать-версию-текущего-softdevice-а-зашитого-в-устройство"><a href="#Как-узнать-версию-текущего-softdevice-а-зашитого-в-устройство" class="headerlink" title="Как узнать версию текущего softdevice-а, зашитого в устройство?"></a>Как узнать версию текущего softdevice-а, зашитого в&nbsp;устройство?</h1><p>Идентификатор SoftDevice находится по&nbsp;адресу <code>0x300C</code>. Попробуем извлечь его оттуда.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ JLinkExe -device nrf51822 -<span class="keyword">if</span> swd</span><br><span class="line">J-Link&gt;mem16 0x300C, 1</span><br><span class="line">0000300C = 0067</span><br></pre></td></tr></table></figure><p>По таблице находим что за&nbsp;SoftDevice соответствует этому идентификатору. Если возвращается пустое значение <code>0xFFFF</code> значит SoftDevice не&nbsp;установлен.</p><table><thead><tr><th>SoftDevice</th><th>FWID</th></tr></thead><tbody><tr><td>S110 v7.1.0</td><td>0&times;005A</td></tr><tr><td>S110 v8.0.0</td><td>0&times;0064</td></tr><tr><td>S120 v2.0.0</td><td>0&times;0060</td></tr><tr><td>S130 v1.0.0</td><td>0&times;0067</td></tr><tr><td>S130 0.9alpha</td><td>0&times;005E</td></tr><tr><td>S130 v2.0.0-7.alpha</td><td>0&times;0078</td></tr><tr><td>S310 v2.0.0</td><td>0&times;005D</td></tr><tr><td>S132 v1.0.0-3.alpha</td><td>0&times;006D</td></tr></tbody></table><p>Более подробно тут <a href="https://devzone.nordicsemi.com/question/3629/how-do-i-access-softdevice-version-string/?answer=3693#post-id-3693">https://devzone.nordicsemi.com/question/3629/how-do-i-access-softdevice-version-string/? answer=3693#post-id-3693</a></p><p>Итого как оказалось я&nbsp;залил softdevice S130&nbsp;версии 1. Собственно с&nbsp;SDK v10&nbsp;поставляется именно она поэтому с&nbsp;виду вроде как всё в&nbsp;порядке.</p><p>Для более глубокого погружения в&nbsp;тему&nbsp;&mdash; вот <a href="http://infocenter.nordicsemi.com/pdf/S130_SDS_v1.0.pdf">спецификация на&nbsp;S130 v1.0.0</a>. Уверен, придётся туда заглядывать ещё не&nbsp;раз.</p><h1 id="Тип-чипа"><a href="#Тип-чипа" class="headerlink" title="Тип чипа"></a>Тип чипа</h1><p>В предыдущей статье уже упоминал важность знания конкретной маркировки чипа. В&nbsp;связи с&nbsp;этим заснял свой экземпляр:</p><img src="/2018/01/08/nrf51822-trying-to-make-bluetooth-working/nrf51822-chip-mark.jpg" class="" title="Маркировка чипа nrf51822"><p>Ниже привожу выдержки из&nbsp;документации по&nbsp;конкретно этому чипу. Моей целью было узнать подробно о&nbsp;распределении адресного пространства контроллера, чтобы указать эту информацию линковщику осознанно, а&nbsp;не&nbsp;тупо копипастить куски кода.</p><img src="/2018/01/08/nrf51822-trying-to-make-bluetooth-working/nrf51822-code-organization.png" class="" title="nRF51822 code organization"><img src="/2018/01/08/nrf51822-trying-to-make-bluetooth-working/nrf51822-ram-organization.png" class="" title="nRF51822 RAM organization"><img src="/2018/01/08/nrf51822-trying-to-make-bluetooth-working/nrf51822-ram-variants.png" class="" title="nRF51822 RAM variants"><img src="/2018/01/08/nrf51822-trying-to-make-bluetooth-working/nrf51822-mpu-flash-blocks.png" class="" title="MPU flash blocks"><h1 id="Адресация-S130"><a href="#Адресация-S130" class="headerlink" title="Адресация S130"></a>Адресация S130</h1><p>Итак я&nbsp;нашёл как распределяется адресное пространство контроллера в&nbsp;случае использования SoftDevice S130 v1.</p><img src="/2018/01/08/nrf51822-trying-to-make-bluetooth-working/s130-memory-map.png" class="" title="Адресное пространство S130"><p>На этой схеме:</p><table><thead><tr><th>Параметр</th><th align="right">Значение</th><th>Где найти</th></tr></thead><tbody><tr><td>APP_CODE_BASE</td><td align="right">0&times;1C000</td><td><a href="http://infocenter.nordicsemi.com/index.jsp?topic=/com.nordic.infocenter.softdevices51/dita/nrf51/softdevices.html">Спецификация к&nbsp;SoftDevice</a></td></tr><tr><td>APP_RAM_BASE</td><td align="right">0&times;20002800</td><td><a href="http://infocenter.nordicsemi.com/index.jsp?topic=/com.nordic.infocenter.softdevices51/dita/nrf51/softdevices.html">Спецификация к&nbsp;SoftDevice</a></td></tr><tr><td>SizeOfProgMem</td><td align="right">256k</td><td><a href="http://infocenter.nordicsemi.com/index.jsp?topic=/com.nordic.infocenter.nrf51/dita/nrf51/compatibility_matrix/nRF51822_ic_revision_overview.html&cp=3_0_1">Определить по&nbsp;типу чипа</a></td></tr><tr><td>SizeOfRAM</td><td align="right">16k</td><td><a href="http://infocenter.nordicsemi.com/index.jsp?topic=/com.nordic.infocenter.nrf51/dita/nrf51/compatibility_matrix/nRF51822_ic_revision_overview.html&cp=3_0_1">Определить по&nbsp;типу чипа</a></td></tr></tbody></table><p>И что&nbsp;же&nbsp;это нам даёт? А&nbsp;даёт это нам возможность корректно указать линковщику куда (в какие области памяти)  размещать&nbsp;код. Softdevice передаёт управление программе по&nbsp;конкретному адресу, поэтому эти значения нужно указывать точно иначе код просто не&nbsp;запустится.</p><h1 id="Конфигурация-линкера"><a href="#Конфигурация-линкера" class="headerlink" title="Конфигурация линкера"></a>Конфигурация линкера</h1><p>Чтобы упростить работу со&nbsp;всем этими областями памяти <code>gcc</code> предоставляет нам возможность указать все эти области, а&nbsp;так-же расположение секций кода в&nbsp;специальном файле, который потом можно скормить линковщику и&nbsp;тот в&nbsp;свою очередь раскидает код как надо. В&nbsp;примерах SDK это файлы с&nbsp;расширением <code>ld</code>.</p><h2 id="Секция-MEMORY"><a href="#Секция-MEMORY" class="headerlink" title="Секция MEMORY"></a>Секция MEMORY</h2><p>Здесь задаются значения областей памяти доступных коду программы. В&nbsp;нашем случае мы&nbsp;должны вычислить области флеша и&nbsp;памяти, свободные после заливки в&nbsp;память устройства кода softdevice. Значения по&nbsp;умолчанию можно найти в&nbsp;соответствующих файлах, расположенных в&nbsp;папке <code>components/toolchain/gcc</code>&nbsp;SDK.</p><p>Выглядит это примерно&nbsp;так:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">  FLASH (rx) : ORIGIN = 0x1c000, LENGTH = 0x24000</span><br><span class="line">  RAM (rwx) :  ORIGIN = 0x20002800, LENGTH = 0x5800</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Скажем прямо&nbsp;&mdash; сходу ничего непонятно&nbsp;&mdash; какие-то константы и&nbsp;откуда они взялись решительно неясно.</p><h3 id="Как-рассчитать-эти-значения"><a href="#Как-рассчитать-эти-значения" class="headerlink" title="Как рассчитать эти значения"></a>Как рассчитать эти значения</h3><p>Поля <code>ORIGIN</code> берутся из&nbsp;спецификации к&nbsp;SoftDevice-у. Выше в&nbsp;таблицах указаны значения для S130 v1.</p><p>Для флеша</p><ul><li>ORIGIN = APP_CODE_BASE = 0&times;1C000</li><li>LENGTH = &lt; размер флеш памяти&gt;&nbsp;&mdash; ORIGIN = 256k&nbsp;&mdash; 0&times;1C000</li></ul><p>Для ОЗУ</p><ul><li>ORIGIN = APP_RAM_BASE = 0&times;20002800</li><li>LENGTH = &lt; размер ОЗУ&gt;&nbsp;&mdash; (APP_RAM_BASE&nbsp;&mdash; 0&times;20000000)  = 16k&nbsp;&mdash; 0&times;2800</li></ul><p>Для ОЗУ нумерация адресов идёт не&nbsp;с&nbsp;нуля, поэтому и&nbsp;вычитаем начальный адрес.<br>Для ОЗУ так-же есть нюанс&nbsp;&mdash; <code>ORIGIN</code> не&nbsp;фиксирован и&nbsp;в&nbsp;ряде случаев должен быть пересчитан, но&nbsp;это уже нюансы которые описаны в&nbsp;документации.</p><p>В итоге для <code>XXAA</code> чипа и&nbsp;SoftDevice S130&nbsp;v.&nbsp;1&nbsp;конфигурация памяти в&nbsp;файле линковщика будет выглядеть&nbsp;как:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">  FLASH (rx) : ORIGIN = 0x1c000, LENGTH = 256k - 0x1c00</span><br><span class="line">  RAM (rwx) :  ORIGIN = 0x20002800, LENGTH = 16k - 0x2800</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Секция-SECTIONS"><a href="#Секция-SECTIONS" class="headerlink" title="Секция SECTIONS"></a>Секция SECTIONS</h2><p>Здесь задаются секции кода. В&nbsp;файле <code>components/toolchain/gcc/nrf51_common.ld</code> (ну и&nbsp;соответствующие common файлы для других чипов)  описаны стандартные секции кода, поэтому этот файл всегда включается в&nbsp;файл линковщика.</p><p>Часто встречающаяся секция <code>fs_data</code> и&nbsp;<code>fs_data_out</code> предназначена для хранения информации о&nbsp;привязке (bonding). Ну&nbsp;или для хранения любой другой информации используя API для хранилища если это вам нужно. Поэтому как правило нужна. Более подробно можно почитать в&nbsp;<a href="https://infocenter.nordicsemi.com/index.jsp?topic=/com.nordic.infocenter.sdk51.v10.0.0/lib_section_vars.html&cp=4_0_9_3_30">документации</a></p><h1 id="Какой-пример-будем-запускать"><a href="#Какой-пример-будем-запускать" class="headerlink" title="Какой пример будем запускать?"></a>Какой пример будем запускать?</h1><p>Поковырявшись в&nbsp;примерах решил попробовать этот <code>examples/ble_peripheral/ble_app_uart</code>. Не&nbsp;скажу почему, но&nbsp;с&nbsp;другой стороны почему&nbsp;бы&nbsp;и&nbsp;нет?</p><p>Итак исходный код не&nbsp;трогаю, ибо он&nbsp;мне пока не&nbsp;интересен&nbsp;&mdash; тут&nbsp;бы&nbsp;готовый пример заставить работать, а&nbsp;не&nbsp;с&nbsp;кодом упражняться. В&nbsp;папке вижу подпапку <code>pca10028</code>&nbsp;&mdash; это какая-то демоплата, но&nbsp;у&nbsp;меня такой нет, а&nbsp;есть <code>ble400</code>, просто копирую всю папку <code>pca10028</code> в&nbsp;<code>ble400</code> и&nbsp;далее буду упражняться на&nbsp;ней.</p><p>Заходим в&nbsp;неё и&nbsp;видим знакомые нам подпапки <code>S110</code> и&nbsp;<code>S130</code>. Очевидно нам нужна <code>S130</code> ибо выше всё уже посчитано для&nbsp;неё. Внутри сразу проходим в&nbsp;<code>armgcc</code> и&nbsp;видим знакомые нам Makefile и&nbsp;конфигурацию линковщика. Ну&nbsp;что&nbsp;&mdash; лопату в&nbsp;руки и&nbsp;поехали.</p><h2 id="Правим-Makefile"><a href="#Правим-Makefile" class="headerlink" title="Правим Makefile"></a>Правим Makefile</h2><ol><li>Меняю имя проекта с&nbsp;<code>ble_app_uart_s130_pca10028</code> на&nbsp;<code>ble_app_uart_s130_ble400</code></li><li><code>-DBOARD_PCA10028</code> на&nbsp;<code>-DBOARD_CUSTOM</code></li><li>Добавляю <code>-D__HEAP_SIZE=512</code> к&nbsp;опциям <code>CFLAGS</code> и&nbsp;<code>ASMFLAGS</code></li></ol><p>Ну и&nbsp;собственно и&nbsp;всё. Последнее действие нужно&nbsp;т.&nbsp;к.&nbsp;при сборке выскочила ошибка <code>region RAM overflowed with stack</code>. В&nbsp;общем уменьшение HEAP до&nbsp;515&nbsp;решает проблему, но&nbsp;я&nbsp;больше склоняюсь к&nbsp;мысли переехать на&nbsp;SoftDevice S110, как менее ресурсоёмкий.</p><h2 id="Линковщик"><a href="#Линковщик" class="headerlink" title="Линковщик"></a>Линковщик</h2><p>Выше уже все расписал, поэтому просто приведу свой файл.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* Linker script to configure memory regions. */</span><br><span class="line"></span><br><span class="line">SEARCH_DIR(.)</span><br><span class="line">GROUP(-lgcc -lc -lnosys)</span><br><span class="line"></span><br><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">  FLASH (rx) : ORIGIN = 0x1c000, LENGTH = 256k - 0x1c00</span><br><span class="line">  RAM (rwx) :  ORIGIN = 0x20002800, LENGTH = 16k - 0x2800</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  .fs_data_out ALIGN(4):</span><br><span class="line">  &#123;</span><br><span class="line">    PROVIDE( __start_fs_data = .);</span><br><span class="line">    KEEP(*(fs_data))</span><br><span class="line">    PROVIDE( __stop_fs_data = .);</span><br><span class="line">  &#125; = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INCLUDE &quot;nrf5x_common.ld&quot;</span><br></pre></td></tr></table></figure><h1 id="Сборка"><a href="#Сборка" class="headerlink" title="Сборка"></a>Сборка</h1><p>Просто выполняем команду <code>make</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line"><span class="built_in">rm</span> -rf _build</span><br><span class="line"><span class="built_in">echo</span>  Makefile</span><br><span class="line">Makefile</span><br><span class="line"><span class="built_in">mkdir</span> _build</span><br><span class="line">Compiling file: app_button.c</span><br><span class="line">Compiling file: app_error.c</span><br><span class="line">...</span><br><span class="line">Compiling file: system_nrf51.c</span><br><span class="line">Compiling file: softdevice_handler.c</span><br><span class="line">Compiling file: gcc_startup_nrf51.s</span><br><span class="line">Linking target: nrf51422_xxac_s130.out</span><br><span class="line">make[1]: вход в каталог «/home/roman/.Projects/nrf51/nRF51_SDK_10.0.0_dc26b5e/examples/ble_peripheral/ble_app_uart/ble400/s130/armgcc»</span><br><span class="line">Preparing: nrf51422_xxac_s130.bin</span><br><span class="line">Preparing: nrf51422_xxac_s130.hex</span><br><span class="line"></span><br><span class="line">   text   data    bss    dec    hexfilename</span><br><span class="line">  21980    116   2260  24356   5f24_build/nrf51422_xxac_s130.out</span><br><span class="line"></span><br><span class="line">make[1]: выход из каталога «/home/roman/.Projects/nrf51/nRF51_SDK_10.0.0_dc26b5e/examples/ble_peripheral/ble_app_uart/ble400/s130/armgcc»</span><br></pre></td></tr></table></figure><p>То, что выходной файл имеет неверное имя чипа и&nbsp;его тип не&nbsp;должно смущать, это всего-лишь наименование которое авторы SDK видимо ленятся менять. Поэтому я&nbsp;тоже поленюсь и&nbsp;оставлю как есть. Но&nbsp;тем не&nbsp;менее мы&nbsp;получили файл прошивки <code>nrf51422_xxac_s130.hex</code> и&nbsp;это прекрасно.</p><h1 id="Прошивка"><a href="#Прошивка" class="headerlink" title="Прошивка"></a>Прошивка</h1><p>Давайте&nbsp;же&nbsp;наконец зальём наше творение в&nbsp;модуль и&nbsp;посмотрим как оно работает и&nbsp;работает&nbsp;ли&nbsp;вообще.<br>Расчехляю JLink, соединяю всё как надо и&nbsp;запускаю процесс прошивки. На&nbsp;всякий случай очищу память модуля и&nbsp;заново залью SoftDevice и&nbsp;свой&nbsp;код.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ JLinkExe -device nrf51822 -<span class="keyword">if</span> swd</span><br><span class="line">SEGGER J-Link Commander V4.84f (<span class="string">&#x27;?&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>)</span><br><span class="line">Compiled May  9 2014 20:12:27</span><br><span class="line">Info: Device <span class="string">&quot;NRF51822_XXAA&quot;</span> selected (257 KB flash, 16 KB RAM).</span><br><span class="line">DLL version V4.84f, compiled May  9 2014 20:12:24</span><br><span class="line">Firmware: J-Link ARM V8 compiled Jul 17 2014 12:31:18</span><br><span class="line">Hardware: V8.00</span><br><span class="line">S/N: 158005115</span><br><span class="line">Feature(s): RDI,FlashDL,FlashBP,JFlash,GDBFull</span><br><span class="line">VTarget = 3.332V</span><br><span class="line">Info: Found SWD-DP with ID 0x0BB11477</span><br><span class="line">Info: Found Cortex-M0 r0p0, Little endian.</span><br><span class="line">Info: FPUnit: 4 code (BP) slots and 0 literal slots</span><br><span class="line">Found 1 JTAG device, Total IRLen = 4:</span><br><span class="line">Cortex-M0 identified.</span><br><span class="line">Target interface speed: 100 kHz</span><br><span class="line">J-Link&gt;erase</span><br><span class="line">Erasing device (nRF51822_xxAA)...</span><br><span class="line">Info: J-Link: Flash download: Total time needed: 5.947s (Prepare: 0.510s, Compare: 0.000s, Erase: 5.393s, Program: 0.000s, Verify: 0.000s, Restore: 0.043s)</span><br><span class="line">Erasing <span class="keyword">done</span>.</span><br><span class="line">J-Link&gt;loadfile ../../../../../../components/softdevice/s130/hex/s130_nrf51_1.0.0_softdevice.hex</span><br><span class="line">Info: J-Link: Flash download: Flash programming performed <span class="keyword">for</span> 2 ranges (110592 bytes)</span><br><span class="line">Info: J-Link: Flash download: Total time needed: 16.710s (Prepare: 1.205s, Compare: 0.246s, Erase: 0.000s, Program: 14.484s, Verify: 0.022s, Restore: 0.751s)</span><br><span class="line">J-Link&gt;loadfile _build/nrf51422_xxac_s130.hex</span><br><span class="line">Info: J-Link: Flash download: Flash programming performed <span class="keyword">for</span> 1 range (22528 bytes)</span><br><span class="line">Info: J-Link: Flash download: Total time needed: 4.623s (Prepare: 0.982s, Compare: 0.028s, Erase: 0.000s, Program: 3.104s, Verify: 0.004s, Restore: 0.502s)</span><br><span class="line">J-Link&gt;r</span><br><span class="line">Reset delay: 0 ms</span><br><span class="line">Reset <span class="built_in">type</span> NORMAL: Resets core &amp; peripherals via SYSRESETREQ &amp; VECTRESET bit.</span><br><span class="line">J-Link&gt;g</span><br></pre></td></tr></table></figure><p>Если кого-то пугают ужасные пути подскажу&nbsp;&mdash; в&nbsp;JLink-е есть автодополнение путей по&nbsp;клавише&nbsp;Tab.</p><p>На этом месте плата бодро зажгла светодиоды, что видимо что-то означает, но&nbsp;я&nbsp;не&nbsp;знаю&nbsp;что. Ну&nbsp;как минимум что-то сработало&nbsp;&mdash; теоретически у&nbsp;нас сейчас должно работать Bluetooth устройство. Надо&nbsp;бы&nbsp;его как-то поискать.</p><img src="/2018/01/08/nrf51822-trying-to-make-bluetooth-working/ble400-working.jpg" class="" title="Плата с блютуфом заработала"><h1 id="Результат"><a href="#Результат" class="headerlink" title="Результат"></a>Результат</h1><p>В итоге попробовал просканировать эфир программой &laquo;nRF Connect&raquo; и&nbsp;собственно увидел в&nbsp;списке устройств <code>Nordic_UART</code>, что как&nbsp;бы&nbsp;намекает&nbsp;нам, что устройство функционирует и&nbsp;доступно для подключения.</p><img src="/2018/01/08/nrf51822-trying-to-make-bluetooth-working/nRF-connect-found-device.png" class="" title="Программа nRF Connect обнаружила устройство"><p>Я считаю неплохой результат&nbsp;&mdash; по&nbsp;крайней мере ещё один шаг вперёд.</p><h1 id="Источники"><a href="#Источники" class="headerlink" title="Источники"></a>Источники</h1><ul><li><a href="http://infocenter.nordicsemi.com/pdf/nRF51822_PS_v3.3.pdf">http://infocenter.nordicsemi.com/pdf/nRF51822_PS_v3.3.pdf</a></li></ul>]]></content>
    
    
    <summary type="html">Как запустить BLE стэк на китайском модуле nRF51822.</summary>
    
    
    
    <category term="electronics" scheme="https://diytronic.ru/categories/electronics/"/>
    
    
    <category term="nrf51822" scheme="https://diytronic.ru/tags/nrf51822/"/>
    
    <category term="SoftDevice" scheme="https://diytronic.ru/tags/SoftDevice/"/>
    
    <category term="S130" scheme="https://diytronic.ru/tags/S130/"/>
    
    <category term="Bluetooth" scheme="https://diytronic.ru/tags/Bluetooth/"/>
    
  </entry>
  
  <entry>
    <title>Пробую запустить Bus Pirate под Linux</title>
    <link href="https://diytronic.ru/2017/12/29/bus-pirate-linux-setup/"/>
    <id>https://diytronic.ru/2017/12/29/bus-pirate-linux-setup/</id>
    <published>2017-12-29T19:14:02.000Z</published>
    <updated>2017-12-31T19:06:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>Не так давно узнал про <a href="http://dangerousprototypes.com/docs/Bus_Pirate">Bus Pirate</a>&nbsp;&mdash; устройство для эмуляции и&nbsp;анализа различных протоколов управления электронными устройствами. Ну&nbsp;типа там&nbsp;SPI, I2&thinsp;&deg;C и&nbsp;прочих. Решил пощупать, что за&nbsp;зверь такой и&nbsp;купил у&nbsp;братьев-китайцев это устройство. Сегодня получил на&nbsp;почте заветную посылку и&nbsp;решил проверить как оно работает.</p><span id="more"></span><p>Для начала должен отметить, что в&nbsp;данный момент есть 2&nbsp;версии этого устройства 3-я и&nbsp;4-я. Третья версия является стабильной и&nbsp;наиболее отлаженной, но&nbsp;я&nbsp;купился на&nbsp;магию циферок и&nbsp;купил 4-ю, которая обладает более продвинутым железом и&nbsp;потенциально имеет больше возможностей.</p><p>Изначально хотел купить на&nbsp;старом добром AliExpress-е. Там есть как <a href="http://ali.pub/25fmwu">Bus Pirate v3.6</a> так и&nbsp;<a href="http://ali.pub/25fmub">4-й bus pirate</a>, но&nbsp;что-то не&nbsp;захотелось покупать голую плату и&nbsp;в&nbsp;итоге приобрёл на&nbsp;ebay.com <a href="https://www.ebay.com/itm/Bus-Pirate-v4-Universal-Interface-1-Wire-I2C-SPI-UART-etc-BPv4-Gadget/121432974048?ssPageName=STRK:MEBIDX:IT&_trksid=p2060353.m2749.l2649">Bus Pirate v4</a></p><p>Вот такую штуку я&nbsp;в&nbsp;итоге получил:</p><img src="/2017/12/29/bus-pirate-linux-setup/bus-pirate-unpack.jpg" class="" title="Bus Pirate распаковка"><h1 id="Подключение"><a href="#Подключение" class="headerlink" title="Подключение"></a>Подключение</h1><p>Эта штука работает через USB-&gt; COM порт, поэтому, чтобы не&nbsp;разбираться с&nbsp;номером порта, который ему присвоит система я&nbsp;традиционно задействую классическую линуксовую методику по&nbsp;созданию именованной ссылки на&nbsp;нужное мне устройство. Для этого нужно прописать определённые правила в&nbsp;udev.</p><p>Итак для начала посмотрим как&nbsp;же&nbsp;у&nbsp;нас подключилась эта штуковина. Для этого подключим её&nbsp;по&nbsp;USB и&nbsp;выполнима команду:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ lsusb</span><br><span class="line">...</span><br><span class="line">Bus 003 Device 029: ID 04d8:f7ea Microchip Technology, Inc.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Как мы&nbsp;видим устройство в&nbsp;списке появилось под именем Microchip Technology, Inc. С&nbsp;помощью команды <code>dmesg</code> посмотрим какое имя присвоилось устройству:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg</span><br><span class="line">...</span><br><span class="line">[139614.971483] usb 3-1: new full-speed USB device number 29 using xhci_hcd</span><br><span class="line">[139615.686208] cdc_acm 3-1:1.0: ttyACM0: USB ACM device</span><br><span class="line">[139615.686526] usbcore: registered new interface driver cdc_acm</span><br><span class="line">[139615.686527] cdc_acm: USB Abstract Control Model driver <span class="keyword">for</span> USB modems</span><br></pre></td></tr></table></figure><p>И запросим у&nbsp;<code>udev</code> для этого устройства подробную информацию:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ udevadm info --attribute-walk -n /dev/ttyACM0</span><br><span class="line">    looking at parent device <span class="string">&#x27;/devices/pci0000:00/0000:00:14.0/usb3/3-1&#x27;</span>:</span><br><span class="line">    KERNELS==<span class="string">&quot;3-1&quot;</span></span><br><span class="line">    SUBSYSTEMS==<span class="string">&quot;usb&quot;</span></span><br><span class="line">    DRIVERS==<span class="string">&quot;usb&quot;</span></span><br><span class="line">    ATTRS&#123;authorized&#125;==<span class="string">&quot;1&quot;</span></span><br><span class="line">    ATTRS&#123;avoid_reset_quirk&#125;==<span class="string">&quot;0&quot;</span></span><br><span class="line">    ATTRS&#123;bConfigurationValue&#125;==<span class="string">&quot;1&quot;</span></span><br><span class="line">    ATTRS&#123;bDeviceClass&#125;==<span class="string">&quot;02&quot;</span></span><br><span class="line">    ATTRS&#123;bDeviceProtocol&#125;==<span class="string">&quot;00&quot;</span></span><br><span class="line">    ATTRS&#123;bDeviceSubClass&#125;==<span class="string">&quot;00&quot;</span></span><br><span class="line">    ATTRS&#123;bMaxPacketSize0&#125;==<span class="string">&quot;8&quot;</span></span><br><span class="line">    ATTRS&#123;bMaxPower&#125;==<span class="string">&quot;200mA&quot;</span></span><br><span class="line">    ATTRS&#123;bNumConfigurations&#125;==<span class="string">&quot;1&quot;</span></span><br><span class="line">    ATTRS&#123;bNumInterfaces&#125;==<span class="string">&quot; 2&quot;</span></span><br><span class="line">    ATTRS&#123;bcdDevice&#125;==<span class="string">&quot;0002&quot;</span></span><br><span class="line">    ATTRS&#123;bmAttributes&#125;==<span class="string">&quot;80&quot;</span></span><br><span class="line">    ATTRS&#123;busnum&#125;==<span class="string">&quot;3&quot;</span></span><br><span class="line">    ATTRS&#123;configuration&#125;==<span class="string">&quot;&quot;</span></span><br><span class="line">    ATTRS&#123;devnum&#125;==<span class="string">&quot;29&quot;</span></span><br><span class="line">    ATTRS&#123;devpath&#125;==<span class="string">&quot;1&quot;</span></span><br><span class="line">    ATTRS&#123;idProduct&#125;==<span class="string">&quot;f7ea&quot;</span></span><br><span class="line">    ATTRS&#123;idVendor&#125;==<span class="string">&quot;04d8&quot;</span></span><br><span class="line">    ATTRS&#123;ltm_capable&#125;==<span class="string">&quot;no&quot;</span></span><br><span class="line">    ATTRS&#123;manufacturer&#125;==<span class="string">&quot;Dangerous Prototypes&quot;</span></span><br><span class="line">    ATTRS&#123;maxchild&#125;==<span class="string">&quot;0&quot;</span></span><br><span class="line">    ATTRS&#123;product&#125;==<span class="string">&quot;CDC Test&quot;</span></span><br><span class="line">    ATTRS&#123;quirks&#125;==<span class="string">&quot;0x0&quot;</span></span><br><span class="line">    ATTRS&#123;removable&#125;==<span class="string">&quot;removable&quot;</span></span><br><span class="line">    ATTRS&#123;serial&#125;==<span class="string">&quot;00000001&quot;</span></span><br><span class="line">    ATTRS&#123;speed&#125;==<span class="string">&quot;12&quot;</span></span><br><span class="line">    ATTRS&#123;urbnum&#125;==<span class="string">&quot;78&quot;</span></span><br><span class="line">    ATTRS&#123;version&#125;==<span class="string">&quot; 1.10&quot;</span></span><br></pre></td></tr></table></figure><p>на основе которой создадим файл с&nbsp;правилами для <code>udev</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nvim /etc/udev/rules.d/99-bus-pirate.rules</span><br></pre></td></tr></table></figure><p>Добавляем туда правило которое для заданного набора аттрибутов создаст нам ссылку на&nbsp;созданное устройство.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSYSTEM==&quot;tty&quot;, ATTRS&#123;idVendor&#125;==&quot;04d8&quot;, ATTRS&#123;idProduct&#125;==&quot;f7ea&quot;, ATTRS&#123;serial&#125;==&quot;00000001&quot; GROUP=&quot;users&quot;, MODE=&quot;0666&quot;, SYMLINK+=&quot;buspirate&quot;</span><br></pre></td></tr></table></figure><p>Вытаскиваем устройство и&nbsp;вставляем обратно&nbsp;&mdash; в&nbsp;папке <code>/dev/</code> у&nbsp;нас теперь появилась ссылка на&nbsp;устройство <code>/dev/buspirate</code>, которую мы&nbsp;и&nbsp;будем использовать для доступа к&nbsp;устройству.</p><img src="/2017/12/29/bus-pirate-linux-setup/dev-listing.png" class="" title="Bus Pirate в списке устройств"><p>Ещё раз повторюсь&nbsp;&mdash; нужно&nbsp;это, чтобы не&nbsp;гадать какое устройство использовать для подключения, а&nbsp;чётко знать что воткнув именно это устройство я&nbsp;получу конкретное уникальное для него имя в&nbsp;/dev/.</p><h1 id="Работа-с-устройством"><a href="#Работа-с-устройством" class="headerlink" title="Работа с устройством"></a>Работа с&nbsp;устройством</h1><p>Убедившись, что устройство распознано системой попробуем поиграться с&nbsp;ним. Для подключения буду использовать программу <code>screen</code>, хотя подойдёт любой эмулятор терминала. Фактически мы&nbsp;просто подключаемся по&nbsp;RS232&nbsp;терминалу к&nbsp;bus pirate через COM-порт /dev/buspirate</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ screen /dev/buspirate 115200 8N1</span><br><span class="line">HiZ&gt;</span><br></pre></td></tr></table></figure><p>Ну что&nbsp;&mdash; видим приглашение, что означает, что устройство откликается и&nbsp;готово принимать наши команды.</p><h2 id="Тестирование"><a href="#Тестирование" class="headerlink" title="Тестирование"></a>Тестирование</h2><p>Запустим процедуру самотестирования устройства</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HiZ&gt;~</span><br><span class="line">Disconnect any devices</span><br><span class="line">Connect (ADC to +3.3V)</span><br><span class="line">Space to continue</span><br><span class="line">&lt;жмём любую клавишу и получаем&gt;</span><br><span class="line">AUX OK</span><br><span class="line">MODE LED OK</span><br><span class="line">PULLUP H OK</span><br><span class="line">PULLUP L OK</span><br><span class="line">VREG OK</span><br><span class="line">EEPROM</span><br><span class="line">SCL OK</span><br><span class="line">SDA OK</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>После чего видим кучу самопроверок, оканчивающихся на&nbsp;<code>OK</code> из&nbsp;чего я&nbsp;делаю вывод, что самодиагностика работает и&nbsp;устройство не&nbsp;имеет каких-либо проблем.</p><p>Ну и&nbsp;посмотрим, что у&nbsp;нас за&nbsp;прошивка:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HiZ&gt;i</span><br><span class="line">Bus Pirate v4</span><br><span class="line">Firmware v6.1 r1676</span><br><span class="line">DEVID:0x1019 REVID:0x0004 (24FJ256GB106 UNK)</span><br><span class="line">http://dangerousprototypes.com</span><br></pre></td></tr></table></figure><p>Увы&nbsp;&mdash; не&nbsp;самое новьё, но&nbsp;и&nbsp;не&nbsp;совсем уж&nbsp;старая. Похоже на&nbsp;последнюю официальную, в&nbsp;то&nbsp;время как есть уже Community Edition 7-й версии. Будет время&nbsp;&mdash; прошьюсь на&nbsp;что-то более новое, а&nbsp;пока и&nbsp;так сойдёт.</p><p>Подробнее о&nbsp;командах Bus Pirate можно почитать <a href="http://dangerousprototypes.com/docs/Bus_Pirate_self-test_guide/ru">тут</a><br>По прошивке можно почитать <a href="http://dangerousprototypes.com/docs/Bus_Pirate_v4_firmware_updates">тут</a></p><h1 id="AVR-программатор"><a href="#AVR-программатор" class="headerlink" title="AVR программатор"></a>AVR программатор</h1><p>Тесты это конечно здорово, но&nbsp;хотелось&nbsp;бы&nbsp;каких-то более конкретных примеров. Поэтому решил попробовать bus pirate в&nbsp;качестве AVR программатора&nbsp;&mdash; тем более, что под рукой как раз есть проект на&nbsp;attiny13a.</p><p>Итак для начала подсоединяем bus pirate к&nbsp;контроллеру согласно таблице:</p><table><thead><tr><th align="center">Bus Pirate</th><th align="center">Attiny13A</th><th>Примечение</th></tr></thead><tbody><tr><td align="center">CS</td><td align="center">NRST</td><td></td></tr><tr><td align="center">+5V</td><td align="center">Vcc</td><td></td></tr><tr><td align="center">GND</td><td align="center">GND</td><td></td></tr><tr><td align="center">MOSI</td><td align="center">MOSI</td><td></td></tr><tr><td align="center">MISO</td><td align="center">MISO</td><td></td></tr><tr><td align="center">CLK</td><td align="center">SCK</td><td></td></tr><tr><td align="center">AUX</td><td align="center">XTAL1</td><td>необязательно</td></tr></tbody></table><p>У меня в&nbsp;итоге получился вот такой франкенштейн. Нужно будт конечно на&nbsp;будущее сделать более подходящий шнурок и&nbsp;разъём. </p><img src="/2017/12/29/bus-pirate-linux-setup/bus-pirate-as-avr-programmer.jpg" class="" title="Подключение микроконтроллера к Bus Pirate"><p>В качестве софта для прошивки используем старый добрый <code>avrdude</code> &hellip;., а&nbsp;собственно под linux у&nbsp;нас вроде как больше-то вариантов и&nbsp;нет. По&nbsp;счастью <code>avrdude</code> прекрасно умеет работать с&nbsp;bus pirate. Пробуем:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ avrdude -c buspirate -P /dev/buspirate -p t13 -v</span><br><span class="line"></span><br><span class="line">avrdude: Version 6.3-20171130</span><br><span class="line">         Copyright (c) 2000-2005 Brian Dean, http://www.bdmicro.com/</span><br><span class="line">         Copyright (c) 2007-2014 Joerg Wunsch</span><br><span class="line"></span><br><span class="line">         System wide configuration file is <span class="string">&quot;/etc/avrdude.conf&quot;</span></span><br><span class="line">         User configuration file is <span class="string">&quot;/home/roman/.avrduderc&quot;</span></span><br><span class="line">         User configuration file does not exist or is not a regular file, skipping</span><br><span class="line"></span><br><span class="line">         Using Port                    : /dev/buspirate</span><br><span class="line">         Using Programmer              : buspirate</span><br><span class="line">         AVR Part                      : ATtiny13</span><br><span class="line">         ...</span><br><span class="line">         Programmer Type : BusPirate</span><br><span class="line">         Description     : The Bus Pirate</span><br><span class="line"></span><br><span class="line">Attempting to initiate BusPirate binary mode...</span><br><span class="line">BusPirate binmode version: 1</span><br><span class="line">BusPirate SPI version: 1</span><br><span class="line">avrdude: Paged flash write enabled.</span><br><span class="line">AVR Extended Commands version 20553</span><br><span class="line">avrdude: initialization failed, rc=-2</span><br><span class="line">         Double check connections and try again, or use -F to override</span><br><span class="line">         this check.</span><br><span class="line"></span><br><span class="line">BusPirate reset failed. You may need to powercycle it.</span><br></pre></td></tr></table></figure><p>В общем получили фигу&nbsp;&mdash; ничего не&nbsp;работает. По&nbsp;счастью нашлись страдальцы, которые поимели похожую проблему, но&nbsp;в&nbsp;отличие от&nbsp;меня смогли решить&nbsp;её.&nbsp;Я&nbsp;лишь воспользуюсь чужим опытом. Какой-то индонезийский умелец <a href="http://rndc.or.id/wiki/index.php?title=Troubleshooting_Avrdude_Dan_Bus_Pirate">предложил решение</a>, которое действительно работает. Нужно лишь добавить несколько ключей к&nbsp;<code>avrdude</code>, а&nbsp;именно&nbsp;&mdash; <code>-x ascii -x nopagedread -x nopagedwrite</code> и&nbsp;типа всё должно заработать. Итак пробуем:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ avrdude -c buspirate -P /dev/buspirate -p t13 -v -x ascii -x nopagedread -x nopagedwrite</span><br><span class="line">avrdude: Version 6.3-20171130</span><br><span class="line">...</span><br><span class="line">         Programmer Type : BusPirate</span><br><span class="line">         Description     : The Bus Pirate</span><br><span class="line"></span><br><span class="line">Attempting to initiate BusPirate ASCII mode...</span><br><span class="line">BusPirate: using ASCII mode</span><br><span class="line">BusPirate is now configured <span class="keyword">for</span> SPI</span><br><span class="line">avrdude: AVR device initialized and ready to accept instructions</span><br><span class="line"></span><br><span class="line">Reading | <span class="comment">################################################## | 100% 0.01s</span></span><br><span class="line"></span><br><span class="line">avrdude: Device signature = 0x1e9007 (probably t13)</span><br><span class="line">avrdude: safemode: lfuse reads as 6A</span><br><span class="line">avrdude: safemode: hfuse reads as FF</span><br><span class="line"></span><br><span class="line">avrdude: safemode: lfuse reads as 6A</span><br><span class="line">avrdude: safemode: hfuse reads as FF</span><br><span class="line">avrdude: safemode: Fuses OK (E:FF, H:FF, L:6A)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Всё получилось! Я&nbsp;так-же попробовал заливать в&nbsp;контроллер настоящую прошивку и&nbsp;всё получилось тоже без проблем.</p><p>Более подробно про использование bus pirate в&nbsp;качестве программатора vожно почитать <a href="http://dangerousprototypes.com/docs/Bus_Pirate_AVR_Programming">тут</a></p><h1 id="Первые-итоги"><a href="#Первые-итоги" class="headerlink" title="Первые итоги"></a>Первые итоги</h1><p>Ну во&nbsp;первых как минимум я&nbsp;получил живое и&nbsp;работающее устройство с&nbsp;относительно новой прошивкой&nbsp;&mdash; братья китайцы не&nbsp;обманули и&nbsp;это уже хорошо.</p><p>Как минимум я&nbsp;могу использовать его в&nbsp;качестве программатора для атмеловских контроллеров. Пока что он&nbsp;работает стабильнее, чем китайский usbasp (у меня <a href="http://ali.pub/25hhxw">вот такой</a>), который периодически не&nbsp;может прошить фьюзы, пока не&nbsp;выполнишь стирание чипа, в&nbsp;результате чего в&nbsp;моём Makefile-е для прошивки используется 2&nbsp;команды&nbsp;&mdash; очистка, а&nbsp;потом прошивка. Bus pirate в&nbsp;этом плане работает стабильно и&nbsp;таких проблем не&nbsp;имеет.</p><p>Правда в&nbsp;качестве программатора он&nbsp;имеет нюанс&nbsp;&mdash; питание подаётся только на&nbsp;время прошивки и&nbsp;в&nbsp;остальное время выключается. Я&nbsp;как-то привык запитывать контроллер прямо от&nbsp;программатора и&nbsp;такое поведение немного необычно, но&nbsp;может оно и&nbsp;к&nbsp;лучшему&nbsp;&mdash; отучусь от&nbsp;этой дурацкой привычки.</p><p>В общем в&nbsp;дальнейшем попробую использовать эту эту железяку в&nbsp;различных применениях о&nbsp;чём конечно&nbsp;же&nbsp;отпишусь в&nbsp;очередной статье.</p><h1 id="Источники"><a href="#Источники" class="headerlink" title="Источники"></a>Источники</h1><ul><li><a href="https://wiki.archlinux.org/index.php/Bus_pirate">https://wiki.archlinux.org/index.php/Bus_pirate</a></li><li><a href="http://jumptuck.com/2010/01/21/writing-a-bus-pirate-udev-rule/">http://jumptuck.com/21.01.2010/writing-a-bus-pirate-udev-rule/</a></li><li><a href="https://www.bigmessowires.com/2013/11/19/what-is-the-bus-pirate/">https://www.bigmessowires.com/19.11.2013/what-is-the-bus-pirate/</a></li><li><a href="http://dangerousprototypes.com/docs/Bus_Pirate_102_tutorial/ru">http://dangerousprototypes.com/docs/Bus_Pirate_102_tutorial/ru</a></li></ul>]]></content>
    
    
    <summary type="html">Как подключить в linux bus pirate и попробовать его в качестве AVR программатора</summary>
    
    
    
    <category term="electronics" scheme="https://diytronic.ru/categories/electronics/"/>
    
    
    <category term="avr" scheme="https://diytronic.ru/tags/avr/"/>
    
    <category term="avrdude" scheme="https://diytronic.ru/tags/avrdude/"/>
    
    <category term="linux" scheme="https://diytronic.ru/tags/linux/"/>
    
    <category term="bus-pirate" scheme="https://diytronic.ru/tags/bus-pirate/"/>
    
    <category term="usbisp" scheme="https://diytronic.ru/tags/usbisp/"/>
    
    <category term="avr-programmer" scheme="https://diytronic.ru/tags/avr-programmer/"/>
    
  </entry>
  
  <entry>
    <title>Разработка для STM8 под Linux</title>
    <link href="https://diytronic.ru/2017/12/24/stm8-development-on-linux/"/>
    <id>https://diytronic.ru/2017/12/24/stm8-development-on-linux/</id>
    <published>2017-12-24T16:53:05.000Z</published>
    <updated>2017-12-24T20:02:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>Пару лет назад решил попробовать микроконтроллер STM8. Купил их&nbsp;пачку по&nbsp;дешёвке у&nbsp;китайцев. Как позже оказалось это был STM8S003F3, т.&nbsp;е.&nbsp;дешёвая серия этих контроллеров, но&nbsp;тем не&nbsp;менее с&nbsp;учётом цены вполне неплохо. К&nbsp;сожалению информации по&nbsp;разработке было довольно мало, в&nbsp;особенности по&nbsp;разработке под Linux. Ну&nbsp;и&nbsp;всё, что удалось нарыть собирал в&nbsp;статью, дописать которую сподобился только сейчас.</p><span id="more"></span><p>В итоге чтобы не&nbsp;вводить людей в&nbsp;заблуждение всё перепроверил и&nbsp;результаты выкладываю ниже. В&nbsp;дальнейшем планирую несколько статей по&nbsp;разработке на&nbsp;этих контроллерах. Эта статья типа вводная&nbsp;&mdash; как установить и&nbsp;настроить средства разработки.</p><h1 id="Железо"><a href="#Железо" class="headerlink" title="Железо"></a>Железо</h1><h2 id="STM8"><a href="#STM8" class="headerlink" title="STM8"></a>STM8</h2><p>Для подключения и&nbsp;дальнейшей разработки нам понадобится <a href="http://www.st.com/web/en/resource/technical/document/datasheet/DM00024550.pdf">Даташит</a> и&nbsp;<a href="http://www.st.com/content/ccc/resource/technical/document/reference_manual/9a/1b/85/07/ca/eb/4f/dd/CD00190271.pdf/files/CD00190271.pdf/jcr:content/translations/en.CD00190271.pdf">Мануал</a></p><p>Распиновка контроллера</p><img src="/2017/12/24/stm8-development-on-linux/8S003F3-pinout.gif" class="" title="Распиновка STM8S"><h2 id="ST-LINK"><a href="#ST-LINK" class="headerlink" title="ST-LINK"></a>ST-LINK</h2><p>У меня китайский ST-LINK. Где купил&nbsp;&mdash; уже и&nbsp;не&nbsp;помню. Что-то типа такого <a href="http://ali.pub/24xr7q">StLink v2</a>. Для состоятельных парней готовых заплатить в&nbsp;10&nbsp;раз больше&nbsp;&mdash; можно купить и&nbsp;оригинал <a href="http://ali.pub/24xrqe">Оригинальный ST-Link V2</a>.</p><p>Мой выглядит вот&nbsp;так:</p><img src="/2017/12/24/stm8-development-on-linux/My-ST-LINK.jpg" class="" title="Мой ST-LINK"><p>Для наших экспериментов достаточно подключить 4&nbsp;вывода ST-LINK к&nbsp;соответствующим выводам контроллера.</p><table><thead><tr><th align="center">ST-LINK</th><th align="center">ST-LINK Pin</th><th align="center">STM8</th><th align="center">STM8&nbsp;Pin</th></tr></thead><tbody><tr><td align="center">RST</td><td align="center">1</td><td align="center">NRST</td><td align="center">4</td></tr><tr><td align="center">SWIM</td><td align="center">3</td><td align="center">SWIM</td><td align="center">18</td></tr><tr><td align="center">GND</td><td align="center">5</td><td align="center">Vss</td><td align="center">7</td></tr><tr><td align="center">3.3V</td><td align="center">7</td><td align="center">Vcap</td><td align="center">8</td></tr></tbody></table><h1 id="Компилятор"><a href="#Компилятор" class="headerlink" title="Компилятор"></a>Компилятор</h1><p>Под Linux&nbsp;всё, что нам доступно это компилятор <code>sdcc</code>. В&nbsp;моём ArchLinux-е стандартный пакет <code>sdcc</code> работал, но&nbsp;напрочь отказывался линковать&nbsp;код. Это <a href="https://bugs.archlinux.org/task/55863?project=5&string=sdcc">подтверждённый баг</a> в&nbsp;определённых версиях sdcc, поэтому если при линковке вы&nbsp;не&nbsp;получите на&nbsp;выходе файлы <code>*.ihx</code>, то&nbsp;просто попробуйте откатиться до&nbsp;более старой версии. Ну&nbsp;или до&nbsp;более новой&nbsp;&mdash; я&nbsp;просто скачал текущий девелоперский релиз <a href="https://sourceforge.net/projects/sdcc/files/snapshot_builds/">отсюда</a> и&nbsp;всё заработало.</p><p>Позже в&nbsp;ArchLinux нашёл пакет <code>sdcc-svn</code> который фактически тянет и&nbsp;собирает текущий код проекта. Он&nbsp;тоже оказался работоспособным и&nbsp;в&nbsp;конечном итоге остановился именно на&nbsp;нём. Я&nbsp;всё-таки предпочитаю использовать средства операционной системы, а&nbsp;не&nbsp;городить собственные велосипеды.</p><h1 id="Прошивка"><a href="#Прошивка" class="headerlink" title="Прошивка"></a>Прошивка</h1><p>Выше уже написал, что для прошивки пользуюсь китайским клоном ST-LINK. Для работы с&nbsp;ним в&nbsp;Linux у&nbsp;нас есть проект <a href="https://github.com/vdudouyt/stm8flash">https://github.com/vdudouyt/stm8flash</a>, который и&nbsp;позволяет нам заливать прошивку в&nbsp;устройство.</p><p>По счастью для Arch Linux-а есть готовый пакет и&nbsp;руками собирать ничего не&nbsp;надо.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yaourt -S stm8flash-git</span><br></pre></td></tr></table></figure><p>Как-то&nbsp;бы&nbsp;надо проверить работает&nbsp;ли&nbsp;оно вообще. Поэтому цепляем St-Link и&nbsp;пробуем прочитать содержимое контроллера. Но&nbsp;для начала на&nbsp;всякий пожарный пробуем его разблокировать.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ stm8flash -c stlinkv2 -p stm8s003f3 -u</span><br><span class="line">Determine OPT area</span><br><span class="line">Unlocked device. Option bytes reset to default state.</span><br><span class="line">Bytes written: 11</span><br><span class="line">$ stm8flash -c stlinkv2 -p stm8s003f3 -r test.hex</span><br><span class="line">$ <span class="built_in">cat</span> test.hex</span><br><span class="line">:20800000000000000000000000000000000000000000000000000000000000000000000060</span><br><span class="line">:20802000000000000000000000000000000000000000000000000000000000000000000040</span><br><span class="line">:20804000000000000000000000000000000000000000000000000000000000000000000020</span><br><span class="line">:20806000000000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">:208080000000000000000000000000000000000000000000000000000000000000000000E0</span><br><span class="line">:2080A0000000000000000000000000000000000000000000000000000000000000000000C0</span><br><span class="line">:2080C0000000000000000000000000000000000000000000000000000000000000000000A0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Видим дамп заполненный нулями, что собственно нам и&nbsp;нужно.</p><p>В данном случае я&nbsp;в&nbsp;качестве устройства выбрал stm8s003f3&nbsp;т.&nbsp;к.&nbsp;именно такой контроллер у&nbsp;меня в&nbsp;наличии. Полный&nbsp;же&nbsp;список поддерживаемых устройств можно посмотреть&nbsp;так:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ stm8flash -l</span><br><span class="line">stlux???a stm8af526? stm8af528? stm8af52a? ...</span><br></pre></td></tr></table></figure><h1 id="Стандартная-библиотека"><a href="#Стандартная-библиотека" class="headerlink" title="Стандартная библиотека"></a>Стандартная библиотека</h1><p>Ну что&nbsp;&mdash; железо есть, есть чем заливать прошивку в&nbsp;контроллер. Дело за&nbsp;малым&nbsp;&mdash; написать программу. Но&nbsp;для написания кода крайне желательно иметь уже готовую библиотеку стандартных функций. Для STM8&nbsp;такая библиотека есть. Установка её&nbsp;не&nbsp;вполне тривиальная задача, поэтому остановлюсь на&nbsp;ней поподробнее.</p><p>Основная проблема этой библиотеки это&nbsp;то, что она изначально разрабатывалась под коммерческие компиляторы и&nbsp;соответственно с&nbsp;<code>sdcc</code> работать не&nbsp;будет. Но&nbsp;мир не&nbsp;без добрых людей и&nbsp;нашлись умельцы, доработавшие её&nbsp;до&nbsp;полной совместимости. Но&nbsp;тем не&nbsp;менее все изменения нам придётся вносить вручную &hellip; ну&nbsp;или почти вручную.</p><h2 id="Сборка-вручную"><a href="#Сборка-вручную" class="headerlink" title="Сборка вручную"></a>Сборка вручную</h2><p>Существует несколько патчей от&nbsp;разных умельцев. Изначально я&nbsp;писал эту статью 2&nbsp;года назад и&nbsp;всё было несколько проще. Но&nbsp;попробовав воспроизвести написанные мной&nbsp;же&nbsp;действия понял, что слишком много воды утекло и&nbsp;данные устарели. Поэтому пришлось перебрать несколько вариантов прежде чем получить нужный результат. Здесь выложу только последний&nbsp;&mdash; успешный вариант.</p><p>Итак для начала нам нужно зарегистрироваться на&nbsp;сайте <a href="http://www.st.com/">www.st.com</a>. Раньше это не&nbsp;было обязательным, но&nbsp;сейчас вот оно вот так&nbsp;&mdash; деваться некуда. Сам я&nbsp;выкачать и&nbsp;выложить библиотеку не&nbsp;рискну, ибо обвинения в&nbsp;пиратстве мне не&nbsp;нужны. Придётся каждому делать это самостоятельно.</p><p>После успешной регистрации весь софт с&nbsp;примерами можно найти на&nbsp;этой странице:</p><p><a href="http://www.st.com/en/embedded-software/stm8-embedded-software.html?querycriteria=productId=SC1807">http://www.st.com/en/embedded-software/stm8-embedded-software.html? querycriteria=productId=SC1807</a></p><p>Соответственно для STM8S ищем там STSW-STM8069 (STM8S/A Standard peripheral library).<br>Прямая ссылка&nbsp;&mdash; <a href="http://www.st.com/content/st_com/en/products/embedded-software/mcus-embedded-software/stm8-embedded-software/stsw-stm8069.html">http://www.st.com/content/st_com/en/products/embedded-software/mcus-embedded-software/stm8-embedded-software/stsw-stm8069.html</a><br>И качаем оттуда архив&nbsp;en.stsw-stm8069.zip.</p><p>Для работы нам понадобятся утилиты <code>make</code>, <code>unzip</code> и&nbsp;<code>patch</code>. Они уже должны быть установлены в&nbsp;системе.</p><p>Итак создадим папку и&nbsp;скачиваем туда файл <code>en.stsw-stm8069.zip</code>. Туда&nbsp;же&nbsp;скачиваем мой <a href="https://gist.github.com/webhive/505c2891b6f3c7a253b29e07575ab34c">Makefile</a>. В&nbsp;Makefile-е нужно поправить имя используемого чипа, которое должно быть одним из&nbsp;следующих.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">STM8S208     <span class="comment">/* STM8S High density devices with CAN */</span></span><br><span class="line">STM8S207     <span class="comment">/* STM8S High density devices without CAN */</span></span><br><span class="line">STM8S007     <span class="comment">/* STM8S Value Line High density devices */</span></span><br><span class="line">STM8AF52Ax   <span class="comment">/* STM8A High density devices with CAN */</span></span><br><span class="line">STM8AF62Ax   <span class="comment">/* STM8A High density devices without CAN */</span></span><br><span class="line">STM8S105     <span class="comment">/* STM8S Medium density devices */</span></span><br><span class="line">STM8S005     <span class="comment">/* STM8S Value Line Medium density devices */</span></span><br><span class="line">STM8AF626x   <span class="comment">/* STM8A Medium density devices */</span></span><br><span class="line">STM8AF622x   <span class="comment">/* STM8A Low density devices */</span></span><br><span class="line">STM8S103     <span class="comment">/* STM8S Low density devices */</span></span><br><span class="line">STM8S003     <span class="comment">/* STM8S Value Line Low density devices */</span></span><br><span class="line">STM8S903     <span class="comment">/* STM8S Low density devices */</span></span><br></pre></td></tr></table></figure><p>Имя чипа нужно указать в&nbsp;переменной <code>CHIP</code></p><figure class="highlight make"><figcaption><span>Указываем чип</span><a href="https://gist.github.com/webhive/505c2891b6f3c7a253b29e07575ab34c">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CC = sdcc</span><br><span class="line">AR = sdar</span><br><span class="line"></span><br><span class="line">CHIP = STM8S003</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Далее просто запускаем командой <code>make</code> сборку библиотеки.</p><p>Собственно что при этом происходит? Файл распаковывается, выкачивается нужный патч, накладывается на&nbsp;исходники библиотеки, библиотека собирается, финальный файл вместе с&nbsp;исходниками и&nbsp;заголовочными файлами переносится в&nbsp;папку <code>./&lt;название чипа&gt;_stdlib</code> и&nbsp;затем удаляется весь мусор.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l</span><br><span class="line">итого 10912</span><br><span class="line">-rw-r--r-- 1 roman roman 11164420 дек 23 00:18 en.stsw-stm8069.zip</span><br><span class="line">-rw-r--r-- 1 roman roman     2680 дек 24 20:29 Makefile</span><br><span class="line">drwxr-xr-x 5 roman roman     4096 дек 24 20:58 STM8S003_stdlib</span><br></pre></td></tr></table></figure><p>Готовые файлы будут в&nbsp;папке <code>./&lt;название чипа&gt;_stdlib</code>. В&nbsp;моём случае это <code>STM8S003_stdlib</code>. Внутри будет бинарник библиотеки, заголовочные файлы и&nbsp;исходники (они не&nbsp;нужны, но&nbsp;бывает полезно в&nbsp;них поковыряться, поэтому оставляю их).</p><h2 id="Готовый-проект-на-github"><a href="#Готовый-проект-на-github" class="headerlink" title="Готовый проект на github"></a>Готовый проект на&nbsp;github</h2><p>Нашёл слишком поздно&nbsp;&mdash; <a href="https://github.com/roshbaby/stm8s-sdccvv">тут</a> уже готовая пропатченная библиотека. Знал&nbsp;бы&nbsp;раньше не&nbsp;занимался&nbsp;бы&nbsp;геморроем выше. Справедливости ради должен сказать, что в&nbsp;работе её&nbsp;не&nbsp;проверял.</p><h1 id="Итоги"><a href="#Итоги" class="headerlink" title="Итоги"></a>Итоги</h1><p>Итого у&nbsp;нас всё готово для дальнейшей разработки. В&nbsp;следующих статьях постараюсь показать как это всё использовать.</p><h1 id="Источники"><a href="#Источники" class="headerlink" title="Источники"></a>Источники</h1><ul><li><a href="http://bovs.org/post/111/kompilyator-sdcc-dlya-stm8-v-linux">http://bovs.org/post/111/kompilyator-sdcc-dlya-stm8-v-linux</a></li><li><a href="http://www.count-zero.ru/tags/stm8">http://www.count-zero.ru/tags/stm8</a></li><li><a href="http://kazus.ru/forums/forumdisplay.php?f=33&amp;order=desc&amp;page=2">http://kazus.ru/forums/forumdisplay.php? f=33&amp; order=desc&amp; page=2</a></li><li><a href="https://www.ondrovo.com/a/20170107-stm8-getting-started/">https://www.ondrovo.com/a/20170107-stm8-getting-started/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Пару лет назад решил попробовать микроконтроллер STM8. Купил их пачку по дешёвке у китайцев. Как позже оказалось это был STM8S003F3, т.е. дешёвая серия этих контроллеров, но тем не менее с учётом цены вполне неплохо. К сожалению информации по разработке было довольно мало, в особенности по разработке под Linux. Ну и всё, что удалось нарыть  собирал в статью, дописать которую сподобился только сейчас.&lt;/p&gt;</summary>
    
    
    
    <category term="electronics" scheme="https://diytronic.ru/categories/electronics/"/>
    
    
    <category term="stm8" scheme="https://diytronic.ru/tags/stm8/"/>
    
    <category term="linux" scheme="https://diytronic.ru/tags/linux/"/>
    
    <category term="mcu" scheme="https://diytronic.ru/tags/mcu/"/>
    
    <category term="sdcc" scheme="https://diytronic.ru/tags/sdcc/"/>
    
    <category term="stm8flash" scheme="https://diytronic.ru/tags/stm8flash/"/>
    
    <category term="st-link-2" scheme="https://diytronic.ru/tags/st-link-2/"/>
    
  </entry>
  
  <entry>
    <title>Немного эстетики. Китайские переходники для микросхем</title>
    <link href="https://diytronic.ru/2017/12/20/nice-sop-to-dip-adapters-review/"/>
    <id>https://diytronic.ru/2017/12/20/nice-sop-to-dip-adapters-review/</id>
    <published>2017-12-20T20:19:04.000Z</published>
    <updated>2017-12-31T19:11:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>Для своих экспериментов с&nbsp;микроконтроллерами использую макетные платы&nbsp;&mdash; так называемые бредборды. И&nbsp;всё&nbsp;бы&nbsp;ничего, но&nbsp;контроллеры с&nbsp;планарными корпусами туда не&nbsp;лезут, а&nbsp;покупать в&nbsp;DIP корпусе только ради макета пачку микросхем как-то слишком уж&nbsp;излишество. Поэтому пользовался самодельными колхозными переходниками.</p><span id="more"></span><p>Выглядят они крайне непрезентабельно, но&nbsp;по&nbsp;мне так лишь&nbsp;бы&nbsp;работало. Но&nbsp;вот пару месяцев назад случайно спалил свой макетный вариант attiny13 и&nbsp;встал перед проблемой повторного изготовления этого поделия. Снова колхозить всё проводочками стало как-то очень даже неохота и&nbsp;полез к&nbsp;китайцам&nbsp;&mdash; посмотреть что&nbsp;же&nbsp;там есть для удовлетворения моего внезапно нахлынувшего чувства эстетики.</p><p>Братья-китайцы вполне ожидаемо не&nbsp;подвели&nbsp;&mdash; алиэкспресс просто ломился от&nbsp;всякого рода переходников и&nbsp;адаптеров. Из&nbsp;всего многообразия были выбраны следующие:</p><p><a href="http://ali.pub/24mis4">Адаптеры SOP8&nbsp;to&nbsp;DIP8</a><br><a href="http://ali.pub/24mj4k">Набор адаптеров SOP -&gt; DIP</a><br><a href="http://ali.pub/24mj82">Набор адаптеров QFN -&gt; DIP</a><br><a href="http://ali.pub/24mjn1">Адаптеры SMT -&gt; DIP</a><br><a href="http://ali.pub/24mjso">Набор адаптеров SOP -&gt; DIP</a><br><a href="http://ali.pub/24mjv0">Адаптеры QFN32 -&gt; DIP32</a><br><a href="http://ali.pub/24mjyw">Адаптеры QFN48 -&gt; DIP48</a></p><p>И вот на&nbsp;днях получил пачку платок и&nbsp;не&nbsp;откладывая в&nbsp;долгий ящик решил переделать пару своих говноплаток.</p><p>Во первых это была моя многострадальная горелая тинька.</p><img src="/2017/12/20/nice-sop-to-dip-adapters-review/IMG_20171219_234029.jpg" class="" title="Пример использования адаптера SOP8 DIP8 для микроконтроллера Attiny13"><p>Вторым подопытным стал мой неудачный эксперимент с&nbsp;STM8, в&nbsp;котором я&nbsp;так и&nbsp;не&nbsp;смог заставить работать как надо энкодер и&nbsp;в&nbsp;результате переделал работу на&nbsp;Atmega8. Предполагаю, что это просто китайцы подсунули гнилой контроллер ибо перебрал уже все варианты и&nbsp;собственно схема включения и&nbsp;код были типовые. Но&nbsp;перепаивать было уже лень, а&nbsp;тут как раз выдался случай попробовать в&nbsp;работе новые переходнички.</p><img src="/2017/12/20/nice-sop-to-dip-adapters-review/IMG_20171219_234117.jpg" class="" title="Пример использования адаптера SSOP20 DIP20 для микроконтроллера STM8"><p>В итоге получил вполне симпатичные варианты, что меня полностью устраивает. Собственно никакой прикладной цели эта статья не&nbsp;несёт. Просто вариант.</p>]]></content>
    
    
    <summary type="html">Пример использования китайских пререходников с планарных корпусов на DIP</summary>
    
    
    
    <category term="electronics" scheme="https://diytronic.ru/categories/electronics/"/>
    
    
    <category term="attiny13" scheme="https://diytronic.ru/tags/attiny13/"/>
    
    <category term="stm8" scheme="https://diytronic.ru/tags/stm8/"/>
    
    <category term="DIP" scheme="https://diytronic.ru/tags/DIP/"/>
    
    <category term="SOP" scheme="https://diytronic.ru/tags/SOP/"/>
    
    <category term="QFN" scheme="https://diytronic.ru/tags/QFN/"/>
    
    <category term="attiny13a" scheme="https://diytronic.ru/tags/attiny13a/"/>
    
    <category term="adapters" scheme="https://diytronic.ru/tags/adapters/"/>
    
  </entry>
  
  <entry>
    <title>Пробую NRF51822</title>
    <link href="https://diytronic.ru/2017/12/05/testing-nrf51822-ble-module/"/>
    <id>https://diytronic.ru/2017/12/05/testing-nrf51822-ble-module/</id>
    <published>2017-12-05T18:49:24.000Z</published>
    <updated>2018-01-09T18:49:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>Есть у&nbsp;меня китайский <a href="http://ali.pub/2617ov">BLE модуль на&nbsp;nRF51822</a>. Давно собирался с&nbsp;ним поэкспериментировать и&nbsp;вот руки наконец дошли. К&nbsp;сожалению информации о&nbsp;работе с&nbsp;этими модулями не&nbsp;так много, поэтому решил поделиться своим опытом.</p><span id="more"></span><h1 id="Железо"><a href="#Железо" class="headerlink" title="Железо"></a>Железо</h1><h2 id="Модуль-nRF51822"><a href="#Модуль-nRF51822" class="headerlink" title="Модуль nRF51822"></a>Модуль nRF51822</h2><img src="/2017/12/05/testing-nrf51822-ble-module/nrf51822-module.jpg" class="" title="Фото nRF51822 модуля"><p>Собственно модуль представляет собой распаянный на&nbsp;плату чип nRF51822 с&nbsp;всей необходимой обвязкой и&nbsp;пинами выведенными на&nbsp;пару гребёнок. Ну&nbsp;и&nbsp;как любой микроконтроллер он&nbsp;может быть прошит неким кодом, который может управлять портами ввода/вывода. Ну&nbsp;и&nbsp;главным бонусом идёт встроенный Bluetooth LE&nbsp;модуль.</p><p>Хочу особо обратить внимание на&nbsp;тот факт, что существует несколько вариаций чипа с&nbsp;разными вариантам памяти. Это будет важно в&nbsp;дальнейшем. Поэтому советую посмотреть прямо на&nbsp;чипе маркировку.</p><img src="/2017/12/05/testing-nrf51822-ble-module/nrf51-chip-markings.png" class="" title="Маркировка чипа nRF51822"><p>Естественным желанием было воткнуть модуль в&nbsp;брэдборд и&nbsp;потестировать. Но&nbsp;не&nbsp;ту-то было. Модуль имеет 4&nbsp;ряда выводов, что как&nbsp;бы&nbsp;уже обламывает всю идею, но&nbsp;к&nbsp;тому-же оказалось выводы имеют нестандартный шаг 2&nbsp;мм, так что даже на&nbsp;макетку его не&nbsp;воткнуть. В&nbsp;поисках какого-нибудь переходника наткнулся на&nbsp;готовую отладочную плату для таки модулей <a href="http://ali.pub/25xm36">BLE400</a>.</p><h2 id="Плата-BLE400"><a href="#Плата-BLE400" class="headerlink" title="Плата BLE400"></a>Плата BLE400</h2><img src="/2017/12/05/testing-nrf51822-ble-module/ble400-board.jpg" class="" title="Фото платы BLE400"><p>Вариант с&nbsp;платой выглядел поинтереснее, поэтому данная плата немедленно <a href="http://ali.pub/25xm36">была закуплена у&nbsp;китайских коммерсантов</a>. Собственно эта плата представляет собой разъём для модуля, пины, выведенные на&nbsp;штырьки, некоторые пины выведены на&nbsp;светодиоды (через перемычки), 2&nbsp;пина подключены к&nbsp;кнопкам (опять&nbsp;же&nbsp;через перемычки). Так-же есть несколько стандартных разъёмов опять&nbsp;же&nbsp;подключенных к&nbsp;пинам модуля и&nbsp;USB -&gt; COM преобразователь, который позволяет во&nbsp;первых запитать модуль через&nbsp;USB, а&nbsp;во&nbsp;вторых позволяет использовать UART прямо через&nbsp;USB. В&nbsp;общем простая, но&nbsp;полезная штука.</p><p>Итак плата BLE400 в&nbsp;наличии, модуль воткнут в&nbsp;разъём.</p><p>Втыкаем плату и&nbsp;видим в&nbsp;логах, что она определилась как /dev/ttyUSB0</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg</span><br><span class="line">...</span><br><span class="line">[35577.734982] usbcore: registered new interface driver usbserial</span><br><span class="line">[35577.734992] usbcore: registered new interface driver usbserial_generic</span><br><span class="line">[35577.734999] usbserial: USB Serial support registered <span class="keyword">for</span> generic</span><br><span class="line">[35577.738586] usbcore: registered new interface driver cp210x</span><br><span class="line">[35577.738596] usbserial: USB Serial support registered <span class="keyword">for</span> cp210x</span><br><span class="line">[35577.738619] cp210x 3-1:1.0: cp210x converter detected</span><br><span class="line">[35577.740213] usb 3-1: cp210x converter now attached to ttyUSB0</span><br></pre></td></tr></table></figure><p>Надо для неё проделать старый хитрый трюк с&nbsp;udev, чтобы получить стабильное неизменное&nbsp;имя. Ну&nbsp;что&nbsp;&mdash; поехали. Находим соответствующee USB устройство.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ lsusb</span><br><span class="line">...</span><br><span class="line">Bus 003 Device 071: ID 10c4:ea60 Cygnal Integrated Products, Inc. CP2102/CP2109 UART Bridge Controller [CP210x family]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Смотрим udev аттрибуты</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ udevadm info --attribute-walk -n /dev/ttyUSB0</span><br><span class="line">...</span><br><span class="line">    ATTRS&#123;idProduct&#125;==<span class="string">&quot;ea60&quot;</span></span><br><span class="line">    ATTRS&#123;idVendor&#125;==<span class="string">&quot;10c4&quot;</span></span><br><span class="line">    ...</span><br><span class="line">    ATTRS&#123;serial&#125;==<span class="string">&quot;0001&quot;</span></span><br></pre></td></tr></table></figure><p>И прописываем его в&nbsp;правило udev</p><figure class="highlight plaintext"><figcaption><span>/etc/udev/rules.d/99-ble400.rules</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSYSTEM==&quot;tty&quot;, ATTRS&#123;idVendor&#125;==&quot;10c4&quot;, ATTRS&#123;idProduct&#125;==&quot;ea60&quot;, ATTRS&#123;serial&#125;==&quot;0001&quot; GROUP=&quot;users&quot;, MODE=&quot;0666&quot;, SYMLINK+=&quot;ble400&quot;</span><br></pre></td></tr></table></figure><p>Теперь перезагружаем правила</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo udevadm control --reload-rules</span><br></pre></td></tr></table></figure><p>И отсоединяем/подсоединяем кабель устройства и&nbsp;наблюдаем в&nbsp;папке /dev/ устройство ble400&nbsp;которое является фактически ссылкой на&nbsp;реальный файл устройства. Ну,&nbsp;а&nbsp;нам того и&nbsp;надо.</p><h1 id="Подключение-и-прошивка"><a href="#Подключение-и-прошивка" class="headerlink" title="Подключение и прошивка"></a>Подключение и&nbsp;прошивка</h1><p>В сети нашёл несколько вариантов общения с&nbsp;модулем. Как правило по&nbsp;умолчанию модуль должен иметь встроенный UART, что теоретически должно дать нам возможность как минимум проверить подаёт&nbsp;ли&nbsp;модуль какие-то признаки жизни.</p><h2 id="USB-serial"><a href="#USB-serial" class="headerlink" title="USB serial"></a>USB serial</h2><p>Итак втыкаем плату с&nbsp;модулем в&nbsp;USB разъём и&nbsp;пробуем подключиться к&nbsp;UART-у. В&nbsp;ответ на&nbsp;посылку ему команду &laquo;y&raquo; от&nbsp;должен ответить &laquo;Start &hellip;&raquo;.</p><p>Не прокатило&nbsp;&mdash; не&nbsp;отзывается на&nbsp;команды вообще никак. Только загорается светодиод&nbsp;SPD. При отправке команды &laquo;y&raquo; моргает&nbsp;Rx.&nbsp;Возможно просто в&nbsp;чипе хрен знает какая прошивка или он&nbsp;вообще девственно чист. Т.е. вроде как соединения устанавливается, но&nbsp;ни&nbsp;на&nbsp;какие команды не&nbsp;реагирует. Возможно (и скорей всего)  нужно просто подобрать правильную скорость соединения.</p><p>Ну как говорится&nbsp;&mdash; &laquo;не очень-то и&nbsp;хотелось&raquo;. Будем пробовать дальше. Вопрос с&nbsp;работоспособностью по&nbsp;прежнему остаётся открытым.</p><h2 id="Bluetooth"><a href="#Bluetooth" class="headerlink" title="Bluetooth"></a>Bluetooth</h2><p>Попытка номер&nbsp;два. Предположил, что при подключении у&nbsp;нас должно быть видно какое-то Bluetooth устройство. Втыкаем опять плату с&nbsp;модулем в&nbsp;USB, чтоб подать питание. Для тестирования использовал смартфон Xiaomi mi4c, который имеет поддержку&nbsp;BLE. Для тестирования использовал софт от&nbsp;нордиков&nbsp;&mdash; <a href="https://play.google.com/store/apps/details?id=no.nordicsemi.android.nrftoolbox&hl=ru">nRF Toolbox</a> и&nbsp;<a href="https://play.google.com/store/apps/details?id=no.nordicsemi.android.mcp&hl=ru">nRF Connect</a>. Но&nbsp;всё тщетно&nbsp;&mdash; никаких признаков неизвестных BLE устройств обнаружено не&nbsp;было. Это как-то уже начинает напрягать.</p><h2 id="Bus-Pirate"><a href="#Bus-Pirate" class="headerlink" title="Bus Pirate"></a>Bus Pirate</h2><p>Вот тут <a href="http://floe.butterbrot.org/matrix/hacking/nrf/">http://floe.butterbrot.org/matrix/hacking/nrf/</a> какие-то ребята экспериментируют с&nbsp;подключением через Bus Pirate. Попробовал данный вариант&nbsp;&mdash; к&nbsp;плате могу подконнектиться, прочитать память, записать туда что-то. Но&nbsp;возможности крайне скудные. Там какой-то самописный программатор собранный на&nbsp;коленке под конкретный девайс. Заглянул в&nbsp;код и&nbsp;закрыл от&nbsp;греха подальше. Всё, что можно узнать о&nbsp;подключенном устройстве это первые 1000&nbsp;байт из&nbsp;памяти. Ну&nbsp;и&nbsp;записать в&nbsp;устройство можно все что угодно начиная с&nbsp;заданного адреса.</p><p>Однако это уже первый позитивный опыт&nbsp;&mdash; по&nbsp;крайней мере устройство отзывалось и&nbsp;давало записать в&nbsp;себя файлы прошивок. В&nbsp;остальном&nbsp;&mdash; никакого толку.</p><h2 id="J-link"><a href="#J-link" class="headerlink" title="J-link"></a>J-link</h2><p>Ну что&nbsp;&mdash; пришлось расчехлить старый добрый J-Link, который уже давно пылился на&nbsp;полке. К&nbsp;этому моменту я&nbsp;уже изрядно <del>подзае</del> наковырялся с&nbsp;SDK и&nbsp;даже читал стандартную документацию из&nbsp;комплекта, поэтому в&nbsp;теме уже немножко шарил. Оказывается J-Link это как раз и&nbsp;есть самый прямой путь к&nbsp;счастью. Да&nbsp;и&nbsp;на&nbsp;плате BLE400&nbsp;есть готовый разъём, поэтому она немедленно была вкорячена в&nbsp;J-Link-овский шлейфик и&nbsp;<strong>внимание!</strong> это важно подключена через USB к&nbsp;компьютеру. Как оказалось J-Link напрочь отказывается питать подключенное устройство.</p><p>В итоге получаем что-то эдакое:</p><img src="/2017/12/05/testing-nrf51822-ble-module/ble400-and-jlink.jpg" class="" title="Подключение BLE400 к JLink"><p><strong>Важно!!!</strong></p><p>Владельцев китайских J-Link-ов предупреждаю&nbsp;&mdash; не&nbsp;пользоваться стандартной программой для прошивки из&nbsp;SDK <code>nrfjprog</code>. Она использует родную библиотеку от&nbsp;SEGGER, которая палит, что устройство является китайским клоном и&nbsp;убивает его (по счастью не&nbsp;намертво). Я&nbsp;на&nbsp;эти грабли наступил, но&nbsp;косяк этот для меня не&nbsp;в&nbsp;диковинку, поэтому быстро всё восстановил. Ну,&nbsp;а&nbsp;остальные&nbsp;&mdash; на&nbsp;свой риск и&nbsp;страх&nbsp;&mdash; я&nbsp;вас предупредил.</p><p>Собственно именно по&nbsp;этой причине на&nbsp;фото J-Link в&nbsp;разобранном состоянии&nbsp;&mdash; пришлось его заново перешивать, что невозможно без разбора.</p><p>Итак берём рабочий софт от&nbsp;J-Link и&nbsp;пробуем подключится J-Link Commander-ом. Собственно в&nbsp;командной строке указываем имя устройства (я был реально удивлён, что J-Link &laquo;знает&raquo; о&nbsp;nRF51822), скорость и&nbsp;тип подключения (swd) </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ JLinkExe -device nrf51822 -speed 1000 -<span class="keyword">if</span> swd</span><br><span class="line">SEGGER J-Link Commander V4.84f (<span class="string">&#x27;?&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>)</span><br><span class="line">Compiled May  9 2014 20:12:27</span><br><span class="line">Info: Device <span class="string">&quot;NRF51822_XXAA&quot;</span> selected (257 KB flash, 16 KB RAM).</span><br><span class="line">DLL version V4.84f, compiled May  9 2014 20:12:24</span><br><span class="line">Firmware: J-Link ARM V8 compiled Jul 17 2014 12:31:18</span><br><span class="line">Hardware: V8.00</span><br><span class="line">S/N: 158005115</span><br><span class="line">Feature(s): RDI,FlashDL,FlashBP,JFlash,GDBFull</span><br><span class="line">VTarget = 3.332V</span><br><span class="line">Info: Found SWD-DP with ID 0x0BB11477</span><br><span class="line">Info: Found Cortex-M0 r0p0, Little endian.</span><br><span class="line">Info: FPUnit: 4 code (BP) slots and 0 literal slots</span><br><span class="line">Found 1 JTAG device, Total IRLen = 4:</span><br><span class="line">Cortex-M0 identified.</span><br><span class="line">Target interface speed: 1000 kHz</span><br><span class="line">J-Link&gt;</span><br></pre></td></tr></table></figure><p>Как мы&nbsp;видим произошло успешное подключение и&nbsp;даже определился тип чипа <code>Device &quot;NRF51822_XXAA&quot;</code>, память <code>(257 KB flash, 16 KB RAM)</code> и&nbsp;процессор <code>Found Cortex-M0 r0p0</code>, что как&nbsp;бы&nbsp;намекает&nbsp;нам, что ура&nbsp;&mdash; всё работает.<br>Итак модуль подключен и&nbsp;подаёт признаки жизни&nbsp;&mdash; теперь осталось попробовать залить туда какой-то код и&nbsp;убедиться, что он&nbsp;заработает ну&nbsp;и&nbsp;что вообще мы&nbsp;можем в&nbsp;дальнейшем писать под него&nbsp;код.</p><p>Ну и&nbsp;остаётся нераскрыта тема SWD программаторов, коих у&nbsp;китайцев несть числа. Теоретически они должны работать, т.&nbsp;к.&nbsp;это урезанные JLink-и работающие только через&nbsp;SWD. Но&nbsp;у&nbsp;меня такого под рукой&nbsp;нет, поэтому сказать ничего не&nbsp;могу.</p><h1 id="Софт"><a href="#Софт" class="headerlink" title="Софт"></a>Софт</h1><p>С софтом дело оказалось очень даже неплохо, хотя и&nbsp;немного запутано. Итак компания Nordic поставляет полный набор софта для разработки, кучу примеров и&nbsp;документации.</p><p>Качаем SDK с&nbsp;сайта <a href="https://developer.nordicsemi.com/nRF51_SDK/">https://developer.nordicsemi.com/nRF51_SDK/</a></p><p>Казалось&nbsp;бы&nbsp;вполне логично взять распоследнюю версию&nbsp;SDK. На&nbsp;сегодняшний день (январь 2018)  это v14. Но&nbsp;не&nbsp;тут-то было. В&nbsp;принципе оно как&nbsp;бы&nbsp;должно работать, но&nbsp;SDK версии 14&nbsp;полностью ориентирован на&nbsp;чипы серии nRF52 и&nbsp;все примеры по&nbsp;умолчанию используют библиотеки именно для этих чипов.</p><p>Я конечно вызов принял и&nbsp;было даже попробовал заменить ссылки на&nbsp;библиотеки для nRF51,&nbsp;но&nbsp;не&nbsp;особо преуспел в&nbsp;этом. Код успешно собирается, но&nbsp;залитый в&nbsp;устройство не&nbsp;работает. Пока притормозил эту тему&nbsp;&mdash; думаю можно заставить его работать, но&nbsp;я&nbsp;пока решил взять SDK более старой версии, а&nbsp;именно v10. Просто наугад: )  Ну&nbsp;и&nbsp;обнаружил, что там как раз всё вертится вокруг nRF51&nbsp;семейства, что мне и&nbsp;нужно.</p><p>Итого для чипов семейства nRF51&nbsp;стоит начать обучение с&nbsp;SDK v10. Просто будет чуть проще начать.</p><p>Итак качаем и&nbsp;распаковываем <a href="https://developer.nordicsemi.com/nRF51_SDK/nRF51_SDK_v10.x.x/nRF51_SDK_10.0.0_dc26b5e.zip">nRF51_SDK_10.0.0</a></p><h2 id="Немного-теории"><a href="#Немного-теории" class="headerlink" title="Немного теории"></a>Немного теории</h2><p>Как уже писал выше чип nRF51822&nbsp;это в&nbsp;общем-то обычный микроконтроллер. Поэтому мы&nbsp;можем просто написать для него&nbsp;код, залить в&nbsp;устройство и&nbsp;наслаждаться работой. Проблема тут одна&nbsp;&mdash; Bluetooth. При таком подходе нужно будет написать свой Bluetooth стэк, что хоть и&nbsp;в&nbsp;принципе возможно, но&nbsp;крайне трудно осуществимо иначе мне лишь останется позавидовать вашим способностям и&nbsp;крайне удивится зачем вы&nbsp;это читаете.</p><p>В принципе можно использовать этот чип не&nbsp;задействовав Bluetooth&nbsp;&mdash; просто как микроконтроллер. Но&nbsp;зачем, Ватсон?! Ну&nbsp;в&nbsp;общем это очевидный бред и&nbsp;нелепость.</p><p>Простым&nbsp;же&nbsp;смертным людям, которым от&nbsp;этого модуля нужен всё-таки Bluetooth нужен какой-то способ этот Bluetooth использовать прямо здесь и&nbsp;сейчас. И&nbsp;вот для этого случая компания Nordic поставляет некоторый&nbsp;код, называемый softdevice. Фактически это некая мини операционная система которая прошивается в&nbsp;устройство, а&nbsp;свой код мы&nbsp;пишем уже используя API этого softdevice-а.</p><h2 id="Softdevice"><a href="#Softdevice" class="headerlink" title="Softdevice"></a>Softdevice</h2><p>Именно поэтому в&nbsp;примерах SDK как правило есть примеры в&nbsp;подпапке <code>blank</code>&nbsp;т.&nbsp;е.&nbsp;запускаемые на&nbsp;голом контроллере и&nbsp;примеры для конкретных версий softdevice-ов (с префиксом &laquo;s&raquo;). Как я&nbsp;понял softdevice-ы отличаются набором функций и&nbsp;размещением в&nbsp;памяти. Конкретно для nRF51822&nbsp;есть sofdevice-ы версий <code>s110</code>, <code>s120</code> и&nbsp;<code>s130</code>. Sofdevice-ы поставляются в&nbsp;виде закрытого кода и&nbsp;исходники их&nbsp;недоступны.</p><p>Вот по&nbsp;этой ссылке <a href="https://www.nordicsemi.com/eng/Products/Bluetooth-low-energy/nRF51822">https://www.nordicsemi.com/eng/Products/Bluetooth-low-energy/nRF51822</a> в&nbsp;разделе &laquo;Downloads&raquo; можно скачать softdevice-ы для nRF51822. Я&nbsp;не&nbsp;стал мудрить&nbsp;&mdash; выкачал последний. Внутри просто hex файл прошивки. Кстати чуть позже нашёл в&nbsp;SDK папку <code>softdevice</code> где лежат те-же файлы.</p><p>Ну и&nbsp;чтоб не&nbsp;откладывать дела в&nbsp;долгий ящик зальём что-ли softdevice в&nbsp;наше устройство. Запускаем JLink, цепляем к&nbsp;нему ble400 c&nbsp;модулем и&nbsp;не&nbsp;забываем ble400&nbsp;подключить к&nbsp;источнику питания (просто воткнем в&nbsp;USB компьютера). Ниже привожу последовательность команд JLink для заливки softdevice-а:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">J-Link&gt;r</span><br><span class="line">Reset delay: 0 ms</span><br><span class="line">Reset <span class="built_in">type</span> NORMAL: Resets core &amp; peripherals via SYSRESETREQ &amp; VECTRESET bit.</span><br><span class="line">J-Link&gt;w4 4001e504 2</span><br><span class="line">Writing 00000002 -&gt; 4001E504</span><br><span class="line">J-Link&gt;w4 4001e50c 1</span><br><span class="line">Writing 00000001 -&gt; 4001E50C</span><br><span class="line">J-Link&gt;w4 4001e514 1</span><br><span class="line">Writing 00000001 -&gt; 4001E514</span><br><span class="line">J-Link&gt;w4 4001e504 0</span><br><span class="line">Writing 00000000 -&gt; 4001E504</span><br><span class="line">J-Link&gt;r</span><br><span class="line">Reset delay: 0 ms</span><br><span class="line">Reset <span class="built_in">type</span> NORMAL: Resets core &amp; peripherals via SYSRESETREQ &amp; VECTRESET bit.</span><br><span class="line">J-Link&gt;loadfile /home/roman/.Projects/nrf51/softdevice/s130_nrf51_2.0.1_softdevice.hex</span><br><span class="line">Info: J-Link: Flash download: Flash programming performed <span class="keyword">for</span> 2 ranges (108544 bytes)</span><br><span class="line">Info: J-Link: Flash download: Total time needed: 2.012s (Prepare: 0.126s, Compare: 0.041s, Erase: 0.000s, Program: 1.827s, Verify: 0.010s, Restore: 0.007s)</span><br><span class="line">J-Link&gt;r</span><br><span class="line">Reset delay: 0 ms</span><br><span class="line">Reset <span class="built_in">type</span> NORMAL: Resets core &amp; peripherals via SYSRESETREQ &amp; VECTRESET bit.</span><br></pre></td></tr></table></figure><p>Команды типа <code>w4</code> это запись 4-х байтового значения по&nbsp;заданному адресу. Конкретно эти я&nbsp;нашёл где-то в&nbsp;сети. Не&nbsp;очень чётко понимаю что там делается. Заявлено было, что это стирание каких-то областей. В&nbsp;общем надо будет подразобраться с&nbsp;этим шаманством. Но&nbsp;тем не&nbsp;менее это работает. Как видно из&nbsp;команды <code>loadfile</code> заливаю туда прямо hex файл.</p><p>Подсмотрел <a href="https://diyiot.wordpress.com/2015/11/29/ble-application-with-nrf51822-firmware-flashing/">тут</a></p><p>На этом считаю заливку softdevice-а законченной. Теперь нам нужно сварить и&nbsp;залить в&nbsp;модуль какой-нибудь интересный&nbsp;код, чтоб убедиться, что мы&nbsp;можем таки им&nbsp;управлять. По&nbsp;традиции это будет мигающий светодиод&nbsp;&mdash; благо их&nbsp;на&nbsp;плате аж&nbsp;5&nbsp;штук и&nbsp;ничего дополнительно делать не&nbsp;надо. Но&nbsp;для начала некоторые нюансы&nbsp;SDK.</p><h2 id="BLE400-и-SDK"><a href="#BLE400-и-SDK" class="headerlink" title="BLE400 и SDK"></a>BLE400 и&nbsp;SDK</h2><p>Как оказалось все примеры рассчитаны на&nbsp;стандартные платы от&nbsp;Nordic. Но&nbsp;в&nbsp;то-же время нордики благородно оставили возможность <a href="http://infocenter.nordicsemi.com/index.jsp?topic=/com.nordic.infocenter.sdk51.v10.0.0/index.html">добавить свою плату</a>. Фактически нужно создать файл где нужно пробить соответствия физических пинов устройства внутренним константам&nbsp;SDK.</p><p>С другой стороны все эти платы в&nbsp;SDK не&nbsp;более чем некие наборы констант (тупо сишные define-ы)  и&nbsp;можно вполне обойтись без всего этого геморроя с&nbsp;поддержкой плат. Тем не&nbsp;менее раз уж&nbsp;разобрался&nbsp;&mdash; поделюсь опытом.</p><p>Для SDK v10&nbsp;все определения плат лежат в&nbsp;папке <code>examples/bsp</code>. Создаём там файл платы <a href="https://gist.github.com/webhive/55a453d2bd319ba7aa5541fceae7e71a">custom_board.h</a>. И&nbsp;в&nbsp;дальнейшем будем использовать именно&nbsp;его.</p><h2 id="Запускаем-тестовый-пример"><a href="#Запускаем-тестовый-пример" class="headerlink" title="Запускаем тестовый пример"></a>Запускаем тестовый пример</h2><p>Как уже писал выше для теста будем использовать простейший пример&nbsp;&mdash; моргающие светодиоды. Такой пример есть&nbsp;SDK. расположен он&nbsp;в&nbsp;папке <code>examples/peripheral/blinky</code>. Как мы&nbsp;видим в&nbsp;ней есть как уже скомпилированные варианты прошивок под различные платы, так и&nbsp;исходники под конкретные платы. Нашей платы BLE400&nbsp;там очевидно&nbsp;нет, поэтому просто скопируем какую-нибудь из&nbsp;существующих и&nbsp;потом подправим её&nbsp;под свои нужды:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> -R pca10028 ble400</span><br></pre></td></tr></table></figure><p>Вот так вот незатейливо. Внутри у&nbsp;нас 2&nbsp;папки <code>blink</code> и&nbsp;<code>s110</code>. Первая нам не&nbsp;нужна и&nbsp;её&nbsp;можно смело удалить, а&nbsp;вторая это как раз вариант под softdevice. В&nbsp;данном случае под <code>s110</code>, хотя мы&nbsp;только что залили в&nbsp;модуль <code>s130</code>, но&nbsp;для такого примитивного примера это не&nbsp;беда.</p><p>Итак входим в&nbsp;папку s110. Внутри подпапки для различных компиляторов. Нас интересует armgcc. Ура&nbsp;&mdash; мы&nbsp;наконец видим Makefile и&nbsp;какой-то ld&nbsp;файл. Ну&nbsp;и&nbsp;к&nbsp;слову исходный код лежит в&nbsp;<code>examples/peripheral/blinky</code>&nbsp;&mdash; это файл <code>main.c</code>. Собственно эти 3&nbsp;файла нам и&nbsp;нужны.</p><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><p>Итак для начала правим Makefile. Заменяем везде <code>CFLAGS  = -DBOARD_PCA10028</code> на&nbsp;<code>CFLAGS  = -DBOARD_CUSTOM</code>. Так-же меняем<br>везде по&nbsp;тексту <code>xxac</code> на&nbsp;<code>xxaa</code>. Причина смотри выше про типы чипов. Пример сделан под другой тип чипа. Ну&nbsp;и&nbsp;нужно заменить имя softdevice-а&nbsp;&mdash; S110&nbsp;на&nbsp;S130.</p><p>Я ещё поменял <code>PROJECT_NAME</code> на&nbsp;<code>PROJECT_NAME := blinky_s110_ble400</code>.</p><h3 id="ld-файл"><a href="#ld-файл" class="headerlink" title="ld файл"></a>ld файл</h3><p>Далее нам надо подправить ld&nbsp;файл <code>blinky_gcc_nrf51.ld</code>&nbsp;&mdash; в&nbsp;этом файле описаны области памяти устройства и&nbsp;по&nbsp;умолчанию там данные для <code>xxac</code> чипов, а&nbsp;у&nbsp;нас <code>xxaa</code>. Поэтому нужно его поправить. Чтобы найти правильные значения для нашего чипа посмотрим папку <code>components/softdevice/s130/toolchain/armgcc</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l components/toolchain/gcc</span><br><span class="line">...</span><br><span class="line">-rw-r--r-- 1 roman roman 391 ноя  9  2015 armgcc_s130_nrf51422_xxaa.ld</span><br><span class="line">-rw-r--r-- 1 roman roman 391 ноя  9  2015 armgcc_s130_nrf51422_xxac.ld</span><br><span class="line">-rw-r--r-- 1 roman roman 391 ноя  9  2015 armgcc_s130_nrf51822_xxaa.ld</span><br><span class="line">-rw-r--r-- 1 roman roman 390 ноя  9  2015 armgcc_s130_nrf51822_xxab.ld</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Вот они родимые. Смотрим что там у&nbsp;нас для <code>xxaa</code>.</p><p>Нас в&nbsp;этом файле интересует блок <code>MEMORY</code>&nbsp;&mdash; берём значения для полей <code>ORIGIN</code> и&nbsp;переносим в&nbsp;наш файл <code>blinky_gcc_nrf51.ld</code>. Далее нам надо посчитать значения полей <code>LENGTH</code>. Для FLASH это будет размер флеш-памяти устройства (для xxaa 256k)  минус размер, который занимает softdevice (для S130&nbsp;это 112k). Для MEM соответственно LENGTH будет равен размеру ОЗУ (16k для xxaa)  минус размер ОЗУ зарезервированный softdevice-ом (для S130&nbsp;&mdash; 10k).</p><p>Итого получаем следующий блок MEMORY, который мы&nbsp;и&nbsp;запишем в&nbsp;ld&nbsp;файл.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">  FLASH (rx) : ORIGIN = 0x1c000, LENGTH = 256k - 112k</span><br><span class="line">  RAM (rwx) :  ORIGIN = 0x20002800, LENGTH = 16k - 10k</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>На этом с&nbsp;ld&nbsp;файлом мы&nbsp;закончили.</p><h3 id="Компиляция"><a href="#Компиляция" class="headerlink" title="Компиляция"></a>Компиляция</h3><p>Да&nbsp;&mdash; совсем забыл&nbsp;&mdash; для сборки все этой истории в&nbsp;системе должны быть установлен компилятор для ARM процессоров. Это пакет <code>gcc-arm-none-eabi</code>. Для успешной сборки нам надо прописать путь к&nbsp;бинарнику компилятора в&nbsp;<code>components/toolchain/gcc/Makefile.posix</code>. Там по&nbsp;умолчанию какой-то хитрый путь, но&nbsp;в&nbsp;моём случае этот файл сейчас выглядит вот так</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GNU_INSTALL_ROOT := /usr/</span><br><span class="line">GNU_VERSION := 4.9.3</span><br><span class="line">GNU_PREFIX := arm-none-eabi</span><br></pre></td></tr></table></figure><p>Ну собственно вроде&nbsp;всё. Теперь возвращаемся в&nbsp;папку с&nbsp;Makefile-ом нашего тестового проекта с&nbsp;мигающим светодиодом. Ну&nbsp;и&nbsp;собственно&nbsp;т.&nbsp;к.&nbsp;у&nbsp;нас всё уже готово просто запускаем сборку.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line"><span class="built_in">rm</span> -rf _build</span><br><span class="line"><span class="built_in">echo</span>  Makefile</span><br><span class="line">Makefile</span><br><span class="line"><span class="built_in">mkdir</span> _build</span><br><span class="line">Compiling file: system_nrf51.c</span><br><span class="line">Compiling file: main.c</span><br><span class="line">Compiling file: nrf_delay.c</span><br><span class="line">Compiling file: gcc_startup_nrf51.s</span><br><span class="line">Linking target: nrf51422_xxaa_s110.out</span><br><span class="line">make[1]: вход в каталог «/home/roman/.Projects/nrf51/nRF51_SDK_10.0.0_dc26b5e/examples/peripheral/blinky/ble400/s110/armgcc»</span><br><span class="line">Preparing: nrf51422_xxaa_s110.bin</span><br><span class="line">Preparing: nrf51422_xxaa_s110.hex</span><br><span class="line"></span><br><span class="line">   text   data    bss    dec    hexfilename</span><br><span class="line">   1432    104    172   1708    6ac_build/nrf51422_xxaa_s110.out</span><br><span class="line"></span><br><span class="line">make[1]: выход из каталога «/home/roman/.Projects/nrf51/nRF51_SDK_10.0.0_dc26b5e/examples/peripheral/blinky/ble400/s110/armgcc</span><br></pre></td></tr></table></figure><p>Как видим всё прошло успешно, правда в&nbsp;выводе мелькает nrf51422 (где-то я&nbsp;не&nbsp;немножко недопилил), но&nbsp;пока оставим это в&nbsp;покое. В&nbsp;данном случае на&nbsp;работу это не&nbsp;повлияет, хотя конечно надо будет разобраться.</p><p>Теперь у&nbsp;нас должна появиться папка <code>_build</code> в&nbsp;которой будет готовый hex файл прошивки.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l _build</span><br><span class="line">-rw-r--r-- 1 roman roman   7300 янв  7 13:23 gcc_startup_nrf51.o</span><br><span class="line">-rw-r--r-- 1 roman roman   1136 янв  7 13:23 main.o</span><br><span class="line">-rwxr-xr-x 1 roman roman   1536 янв  7 13:23 nrf51422_xxaa_s110.bin</span><br><span class="line">-rw-r--r-- 1 roman roman   4367 янв  7 13:23 nrf51422_xxaa_s110.hex    &lt;- вот он</span><br><span class="line">-rw-r--r-- 1 roman roman  26325 янв  7 13:23 nrf51422_xxaa_s110.map</span><br><span class="line">-rwxr-xr-x 1 roman roman 140640 янв  7 13:23 nrf51422_xxaa_s110.out</span><br><span class="line">-rw-r--r-- 1 roman roman    888 янв  7 13:23 nrf_delay.o</span><br><span class="line">-rw-r--r-- 1 roman roman   1328 янв  7 13:23 system_nrf51.o</span><br></pre></td></tr></table></figure><h3 id="Заливаем-прошивку-в-устройство"><a href="#Заливаем-прошивку-в-устройство" class="headerlink" title="Заливаем прошивку в устройство"></a>Заливаем прошивку в&nbsp;устройство</h3><p>Запускаем JLink и&nbsp;BLE400&nbsp;так-же как мы&nbsp;это делали в&nbsp;случае с&nbsp;прошивкой softdevice. Не&nbsp;забываем подавать питание на&nbsp;BLE400! Ну&nbsp;и&nbsp;выполняем следующий набор команд: <code>loadfile</code>, <code>r</code>, <code>g</code>&nbsp;&mdash; смотри ниже.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ JLinkExe -device nrf51822 -speed 1000 -<span class="keyword">if</span> swd</span><br><span class="line">SEGGER J-Link Commander V4.84f (<span class="string">&#x27;?&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>)</span><br><span class="line">Compiled May  9 2014 20:12:27</span><br><span class="line">Info: Device <span class="string">&quot;NRF51822_XXAA&quot;</span> selected (257 KB flash, 16 KB RAM).</span><br><span class="line">DLL version V4.84f, compiled May  9 2014 20:12:24</span><br><span class="line">Firmware: J-Link ARM V8 compiled Jul 17 2014 12:31:18</span><br><span class="line">Hardware: V8.00</span><br><span class="line">S/N: 158005115</span><br><span class="line">Feature(s): RDI,FlashDL,FlashBP,JFlash,GDBFull</span><br><span class="line">VTarget = 3.332V</span><br><span class="line">Info: Found SWD-DP with ID 0x0BB11477</span><br><span class="line">Info: Found Cortex-M0 r0p0, Little endian.</span><br><span class="line">Info: FPUnit: 4 code (BP) slots and 0 literal slots</span><br><span class="line">Found 1 JTAG device, Total IRLen = 4:</span><br><span class="line">Cortex-M0 identified.</span><br><span class="line">Target interface speed: 1000 kHz</span><br><span class="line">J-Link&gt;loadfile ./_build/nrf51422_xxaa_s110.hex</span><br><span class="line">Info: J-Link: Flash download: Flash programming performed <span class="keyword">for</span> 1 range (2048 bytes)</span><br><span class="line">Info: J-Link: Flash download: Total time needed: 0.182s (Prepare: 0.090s, Compare: 0.002s, Erase: 0.043s, Program: 0.036s, Verify: 0.000s, Restore: 0.007s)</span><br><span class="line">J-Link&gt;r</span><br><span class="line">Reset delay: 0 ms</span><br><span class="line">Reset <span class="built_in">type</span> NORMAL: Resets core &amp; peripherals via SYSRESETREQ &amp; VECTRESET bit.</span><br><span class="line">J-Link&gt;g</span><br></pre></td></tr></table></figure><p>После этого наблюдаем плату с&nbsp;мигающими светодиодами.</p><div class="video-container"><iframe src="https://www.youtube.com/embed/34fL2iGT_bc" frameborder="0" loading="lazy" allowfullscreen></iframe></div><p>В итоге всё получилось. Модуль рабочий и&nbsp;его можно успешно прошивать. Теперь осталось проверить остальные возможности и&nbsp;в&nbsp;особенности самую мякотку&nbsp;&mdash;&nbsp;BLE. Но&nbsp;это уже тема для отдельной статьи. Ну&nbsp;и&nbsp;нужно ещё подчистить Makefile, автоматизировать загрузку прошивки&nbsp;&mdash; в&nbsp;общем причесать весь процесс, чтобы не&nbsp;отвлекаться на&nbsp;рутину.</p><h1 id="Продолжение"><a href="#Продолжение" class="headerlink" title="Продолжение"></a>Продолжение</h1><ul><li><a href="/2018/01/08/nrf51822-trying-to-make-bluetooth-working/" title="Пробуем запустить Bluetooth">Пробуем запустить Bluetooth</a></li></ul><h1 id="Источники"><a href="#Источники" class="headerlink" title="Источники"></a>Источники</h1><ul><li><a href="https://devzone.nordicsemi.com/question/70314/program-bluetooth-for-nrf51822-yunjia-board-with-stlink-v2/">https://devzone.nordicsemi.com/question/70314/program-bluetooth-for-nrf51822-yunjia-board-with-stlink-v2/</a></li><li><a href="https://devzone.nordicsemi.com/blogs/22/getting-started-with-nrf51-development-on-mac-os-x/">https://devzone.nordicsemi.com/blogs/22/getting-started-with-nrf51-development-on-mac-os-x/</a></li><li><a href="https://leavesified.wordpress.com/2016/03/24/setup-nrf51-development-on-linux/">https://leavesified.wordpress.com/24.03.2016/setup-nrf51-development-on-linux/</a></li><li><a href="http://floe.butterbrot.org/matrix/hacking/nrf/">http://floe.butterbrot.org/matrix/hacking/nrf/</a></li><li><a href="https://developer.nordicsemi.com/nRF5_SDK/nRF51_SDK_v8.x.x/doc/8.0.0/s110/html/a00067.html">https://developer.nordicsemi.com/nRF5_SDK/nRF51_SDK_v8.x.x/doc/8.0.0/s110/html/a00067.html</a></li><li><a href="https://gist.github.com/bertrandmartel/a38315c5fe79ec5c8c6a9ed90b8df260">https://gist.github.com/bertrandmartel/a38315c5fe79ec5c8c6a9ed90b8df260</a></li><li><a href="https://medium.com/@robertmassaioli/using-the-ble400-and-nrf51822-on-osx-a57ed723510d">https://medium.com/@robertmassaioli/using-the-ble400-and-nrf51822-on-osx-a57ed723510d</a></li><li><a href="https://medium.com/@robertmassaioli/picking-the-right-nrf5-chip-for-you-8e334493a185">https://medium.com/@robertmassaioli/picking-the-right-nrf5-chip-for-you-8e334493a185</a></li><li><a href="https://www.waveshare.com/wiki/NRF51822_Eval_Kit">https://www.waveshare.com/wiki/NRF51822_Eval_Kit</a></li><li><a href="https://www.waveshare.com/nrf51822-eval-kit.htm">https://www.waveshare.com/nrf51822-eval-kit.htm</a></li><li><a href="https://www.funwithelectronics.com/?id=168">https://www.funwithelectronics.com/? id=168</a></li><li><a href="https://github.com/sandeepmistry/arduino-nRF5#flashing-a-softdevice">https://github.com/sandeepmistry/arduino-nRF5#flashing-a-softdevice</a></li><li><a href="http://redbearlab.com/nrf51822-sdk/">http://redbearlab.com/nrf51822-sdk/</a></li><li><a href="https://gustavovelascoh.wordpress.com/2017/01/23/starting-development-with-nordic-nrf5x-and-gcc-on-linux/">https://gustavovelascoh.wordpress.com/23.01.2017/starting-development-with-nordic-nrf5x-and-gcc-on-linux/</a></li><li><a href="https://leavesified.wordpress.com/2016/03/24/setup-nrf51-development-on-linux/">https://leavesified.wordpress.com/24.03.2016/setup-nrf51-development-on-linux/</a></li><li><a href="http://infocenter.nordicsemi.com/index.jsp?topic=/com.nordic.infocenter.softdevices51/dita/nrf51/softdevices.html">http://infocenter.nordicsemi.com/index.jsp? topic=%2Fcom.nordic.infocenter.softdevices51%2Fdita%2Fnrf51%2Fsoftdevices.html</a></li><li><a href="https://diyiot.wordpress.com/2015/11/29/ble-application-with-nrf51822-firmware-flashing/">https://diyiot.wordpress.com/29.11.2015/ble-application-with-nrf51822-firmware-flashing/</a></li></ul>]]></content>
    
    
    <summary type="html">Как настроить рабочее окружение для разработки софта под BLE модули на чипе nRF51822 и запустить на нём первую тестовую программу.</summary>
    
    
    
    <category term="electronics" scheme="https://diytronic.ru/categories/electronics/"/>
    
    
    <category term="bluetooth" scheme="https://diytronic.ru/tags/bluetooth/"/>
    
    <category term="jlink" scheme="https://diytronic.ru/tags/jlink/"/>
    
    <category term="ble" scheme="https://diytronic.ru/tags/ble/"/>
    
    <category term="nrf51822" scheme="https://diytronic.ru/tags/nrf51822/"/>
    
  </entry>
  
  <entry>
    <title>3d печать - избавляемся от запаха</title>
    <link href="https://diytronic.ru/2017/10/24/howto-get-rid-of-3d-printing-filament-smell/"/>
    <id>https://diytronic.ru/2017/10/24/howto-get-rid-of-3d-printing-filament-smell/</id>
    <published>2017-10-24T19:35:08.000Z</published>
    <updated>2017-10-24T20:09:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>Я думаю не&nbsp;секрет, что при 3D печати выделяется запах плавящегося филамента. И&nbsp;даже если это PLA который скорее пахнет, чем воняет всё равно дышать этими испарениями не&nbsp;особо приятно. В&nbsp;случае&nbsp;же&nbsp;с&nbsp;ABS-ом это уже на&nbsp;запах, а&nbsp;жуткая вонь, которая отравляет всё вокруг.</p><span id="more"></span><h1 id="В-чём-собственно-проблема-то"><a href="#В-чём-собственно-проблема-то" class="headerlink" title="В чём собственно проблема-то?"></a>В чём собственно проблема-то?</h1><p>В общем после очередного наезда родных о&nbsp;жуткой вони в&nbsp;квартире я&nbsp;тормознул свои эксперименты в&nbsp;области 3D печати. Как ни&nbsp;крути, а&nbsp;претензии эти вполне обоснованы. Запах явно есть и&nbsp;это отнюдь не&nbsp;запах свежести летнего утра и&nbsp;с&nbsp;этим что-то надо делать.</p><p>Попытка вынести всё на&nbsp;лоджию успехом не&nbsp;увенчалась&nbsp;&mdash; вся вонь так или иначе проникала в&nbsp;комнату, вызывая недоуменные вопросы&nbsp;&mdash; &laquo;чем это у&nbsp;нас воняет?&raquo;. Открытые окна на&nbsp;лоджии не&nbsp;спасали и&nbsp;к&nbsp;тому-же запах стал слышен на&nbsp;улице, о&nbsp;чём мне тоже было доложено (1&nbsp;этаж). Ну&nbsp;и&nbsp;прохладный ветерок из&nbsp;распахнутых окон вовсе не&nbsp;способствовал качеству.</p><p>Были мысли сделать вытяжку, но&nbsp;всё уперлось в&nbsp;пластиковые окна с&nbsp;которыми особо не&nbsp;забалуешь&nbsp;&mdash; врезать в&nbsp;них что-то нестандартное невозможно (насколько я&nbsp;знаю).</p><h1 id="Как-быть-и-что-делать"><a href="#Как-быть-и-что-делать" class="headerlink" title="Как быть и что делать?"></a>Как быть и&nbsp;что делать?</h1><p>И вот в&nbsp;один прекрасный момент в&nbsp;магазине хозтоваров увидав рулон полиэтиленовой плёнки меня посетило озарение и&nbsp;был приобретён за&nbsp;150&nbsp;рублей 3-метровый полиэтиленовый рукав.</p><p>Далее весь принтер вместе с&nbsp;катушкой филамента был помещён в&nbsp;этот рукав, края рукава подвёрнуты и&nbsp;&laquo;бинго!&raquo;&nbsp;&mdash; получаем эрзац термокамеру и&nbsp;почти полное отсутствие запаха.</p><img src="/2017/10/24/howto-get-rid-of-3d-printing-filament-smell/IMG_20171024_222135.jpg" class=""><img src="/2017/10/24/howto-get-rid-of-3d-printing-filament-smell/IMG_20171024_222143.jpg" class=""><img src="/2017/10/24/howto-get-rid-of-3d-printing-filament-smell/IMG_20171024_222154.jpg" class=""><img src="/2017/10/24/howto-get-rid-of-3d-printing-filament-smell/IMG_20171024_222216.jpg" class=""><p>Думаю фото говорят сами за&nbsp;себя и&nbsp;каких-то комментариев не&nbsp;требуют. Хочу только отметить, что запах ухитряется проникнуть в&nbsp;каждую дырку и&nbsp;надо тщательно подворачивать края полиэтилена.</p><p>Из плюсов так-же отмечу отличную видимость индикатора и&nbsp;доступность ручки управления, т.&nbsp;к.&nbsp;полиэтилен достаточно эластичный чтобы вращать энкодер прямо сквозь него. Для доступа к&nbsp;столу нужно просто раскатать край&nbsp;&mdash; при ширине рукава в&nbsp;1,5&nbsp;метра получаем окно окружностью 3&nbsp;метра&nbsp;&mdash; доступ к&nbsp;столу ничем не&nbsp;ограничен.</p><p>Минус только один&nbsp;&mdash; плохо видно область печати. Ну&nbsp;и&nbsp;ещё пожалуй&nbsp;то, что сам принтер прованивает филаментом просто насквозь. Даже флешку достаёшь и&nbsp;от&nbsp;неё устойчивый запах.</p><p>На этом всё&nbsp;&mdash; надеюсь кому-нибудь этот способ пригодится.</p>]]></content>
    
    
    <summary type="html">Как защититься от адской вони расплавленного филамента малой кровью или нищебродский термобокс за пять минут.</summary>
    
    
    
    <category term="3d-print" scheme="https://diytronic.ru/categories/3d-print/"/>
    
    
    <category term="thermobox" scheme="https://diytronic.ru/tags/thermobox/"/>
    
  </entry>
  
  <entry>
    <title>Проблемы с автокалибровкой стола 3d принтера</title>
    <link href="https://diytronic.ru/2017/08/13/marlin-bed-autoleveling-issue/"/>
    <id>https://diytronic.ru/2017/08/13/marlin-bed-autoleveling-issue/</id>
    <published>2017-08-13T11:18:53.000Z</published>
    <updated>2017-08-13T11:42:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>Неожиданно столкнулся с&nbsp;проблемой автокалибровки стола 3D принтера. Стол откалиброван, но&nbsp;печать идёт без использования данных калибровки. Причём иногда оно всё-таки работало как надо.</p><span id="more"></span><p>Как оказалось проблемой был человеческий фактор, а&nbsp;в&nbsp;данном случае конкретно я&nbsp;сам. Пока отлаживал калибровку&nbsp;&mdash; включал её&nbsp;в&nbsp;меню принтера. Когда&nbsp;же&nbsp;перенёс команду включения калибровки в&nbsp;скрипт слайсера тут-то всё и&nbsp;перестало работать. А&nbsp;я&nbsp;просто если замечал, что она выключена (если случайно залазил в&nbsp;меню) &nbsp;&mdash; просто тупо включал её&nbsp;машинально на&nbsp;автопилоте прям в&nbsp;меню.</p><p>В общем как оказалось есть ряд нюансов:</p><ol><li><p>Команда <code>G28</code> для парковки экструдера зачищает все данные автокалибровки из&nbsp;оперативной памяти. Соответственно запускать парковку нужно <strong>до</strong> загрузки данных автокалибровки.</p></li><li><p>Как я&nbsp;выяснил (всё-таки терзали меня смутные сомнения на&nbsp;этот счёт) &nbsp;&mdash; включение использования данных авкалибровки командой <code>G29</code> совершенно не&nbsp;верно. Вместо неё нежно использовать команду <code>M420 S1</code>&nbsp;&mdash; именно она выполняет загрузку данных точек в&nbsp;оперативную память контроллера принтера.</p></li></ol><p>Теперь откалиброванный стол работает абсолютно стабильно и&nbsp;даже визуально видно, что экструдер опускается к&nbsp;самому столу, а&nbsp;не&nbsp;стоит всё время на&nbsp;дном уровне.</p><h1 id="Источники"><a href="#Источники" class="headerlink" title="Источники"></a>Источники</h1><ul><li><a href="http://marlinfw.org/docs/gcode/M420.html">http://marlinfw.org/docs/gcode/M420.html</a></li></ul>]]></content>
    
    
    <summary type="html">Почему не работает автоуровень при автокалибровке стола 3d принтера?</summary>
    
    
    
    <category term="3d-print" scheme="https://diytronic.ru/categories/3d-print/"/>
    
    
    <category term="marlin" scheme="https://diytronic.ru/tags/marlin/"/>
    
    <category term="G29" scheme="https://diytronic.ru/tags/G29/"/>
    
    <category term="auto-leveling" scheme="https://diytronic.ru/tags/auto-leveling/"/>
    
    <category term="bed-calibration" scheme="https://diytronic.ru/tags/bed-calibration/"/>
    
    <category term="M420" scheme="https://diytronic.ru/tags/M420/"/>
    
  </entry>
  
</feed>
